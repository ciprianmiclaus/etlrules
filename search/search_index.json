{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Finrules \u00b6 A python rule engine operating with data frames aimed at the financial services Free software: MIT Documentation: https://ciprianmiclaus.github.io/finrules/ Features \u00b6 TODO Credits \u00b6 This package was created with the ppw tool. For more information, please visit the project page .","title":"Home"},{"location":"#finrules","text":"A python rule engine operating with data frames aimed at the financial services Free software: MIT Documentation: https://ciprianmiclaus.github.io/finrules/","title":"Finrules"},{"location":"#features","text":"TODO","title":"Features"},{"location":"#credits","text":"This package was created with the ppw tool. For more information, please visit the project page .","title":"Credits"},{"location":"api/","text":"Top-level package for Finrules. backends special \u00b6 common special \u00b6 basic \u00b6 RulesBlock ( UnaryOpBaseRule ) \u00b6 Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Parameters: Name Type Description Default rules Iterable[finrules.rule.BaseRule] An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). required Common params: !!! named_input \"Which dataframe to use as the input. Optional.\" When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. !!! named_output \"Give the output of this rule a name so it can be used by another rule as a named input. Optional.\" When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. !!! name \"Give the rule a name. Optional.\" Named rules are more descriptive as to what they're trying to do/the intent. !!! description \"Describe in detail what the rules does, how it does it. Optional.\" Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Source code in finrules/backends/common/basic.py class RulesBlock ( UnaryOpBaseRule ): \"\"\" Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Params: rules: An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). Common params: named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True \"\"\" def __init__ ( self , rules : Iterable [ BaseRule ], named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): self . _rules = [ rule for rule in rules ] assert self . _rules , \"RulesBlock: Empty rules set provided.\" assert all ( isinstance ( rule , BaseRule ) for rule in self . _rules ), [ rule for rule in self . _rules if not isinstance ( rule , BaseRule )] assert self . _rules [ 0 ] . named_input is None , \"First rule in a RulesBlock must consume the main input/output\" assert self . _rules [ - 1 ] . named_input is None , \"Last rule in a RulesBlock must produce the main output\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) def apply ( self , data ): super () . apply ( data ) data2 = RuleData ( main_input = self . _get_input_df ( data ), named_inputs = { k : v for k , v in data . get_named_outputs ()}, strict = self . strict ) for rule in self . _rules : rule . apply ( data2 ) self . _set_output_df ( data , data2 . get_main_output ()) def to_dict ( self ): dct = super () . to_dict () dct [ self . __class__ . __name__ ][ \"rules\" ] = [ rule . to_dict () for rule in self . _rules ] return dct @classmethod def from_dict ( cls , dct , backend ): dct = dct [ \"RulesBlock\" ] rules = [ BaseRule . from_dict ( rule , backend ) for rule in dct . get ( \"rules\" , ())] kwargs = { k : v for k , v in dct . items () if k != \"rules\" } return cls ( rules = rules , ** kwargs ) pandas special \u00b6 basic \u00b6 DedupeRule ( UnaryOpBaseRule ) \u00b6 De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Parameters: Name Type Description Default columns Iterable[str] A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. required keep Literal['first', 'last', 'none'] What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates 'first' named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note MissingColumnError is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. Source code in finrules/backends/pandas/basic.py class DedupeRule ( UnaryOpBaseRule ): \"\"\" De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Args: columns: A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. keep: What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised when a column specified to deduplicate on doesn't exist in the input data frame. Note: MissingColumnError is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. \"\"\" KEEP_FIRST = 'first' KEEP_LAST = 'last' KEEP_NONE = 'none' ALL_KEEPS = ( KEEP_FIRST , KEEP_LAST , KEEP_NONE ) def __init__ ( self , columns : Iterable [ str ], keep : Literal [ KEEP_FIRST , KEEP_LAST , KEEP_NONE ] = KEEP_FIRST , named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . columns = [ col for col in columns ] assert all ( isinstance ( col , str ) for col in self . columns ), \"DedupeRule: columns must be strings\" assert keep in self . ALL_KEEPS , f \"DedupeRule: keep must be one of: { self . ALL_KEEPS } \" self . keep = False if keep == DedupeRule . KEEP_NONE else keep def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if not set ( self . columns ) <= set ( df . columns ): raise MissingColumnError ( f \"Missing column(s) to dedupe on: { set ( self . columns ) - set ( df . columns ) } \" ) df = df . drop_duplicates ( subset = self . columns , keep = self . keep , ignore_index = True ) self . _set_output_df ( data , df ) ProjectRule ( BaseProjectRule , PandasRuleValidationMixin ) \u00b6 Reshapes the data frame to keep, eliminate or re-order the set of columns. Parameters: Name Type Description Default columns The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required exclude When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumnError exception is raised. In non strict mode, the missing columns are ignored. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/basic.py class ProjectRule ( BaseProjectRule , PandasRuleValidationMixin ): \"\"\" Reshapes the data frame to keep, eliminate or re-order the set of columns. Args: columns: The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. exclude: When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumnError exception is raised. In non strict mode, the missing columns are ignored. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised in strict mode only, if any columns are missing from the input data frame. \"\"\" def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) remaining_columns = self . _get_remaining_columns ( df . columns ) df = df [ remaining_columns ] self . _set_output_df ( data , df ) RenameRule ( UnaryOpBaseRule ) \u00b6 Renames a set of columns in the data frame. Parameters: Name Type Description Default mapper Mapping[str, str] A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/basic.py class RenameRule ( UnaryOpBaseRule ): \"\"\" Renames a set of columns in the data frame. Args: mapper: A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised in strict mode only, if any columns (keys) are missing from the input data frame. \"\"\" def __init__ ( self , mapper : Mapping [ str , str ], named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {old_name:new_name}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {old_name:new_name} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if self . strict : if not set ( self . mapper . keys ()) <= set ( df . columns ): raise MissingColumnError ( f \"Missing columns to rename: { set ( self . mapper . keys ()) - set ( df . columns ) } \" ) df = df . rename ( columns = self . mapper ) self . _set_output_df ( data , df ) SortRule ( UnaryOpBaseRule ) \u00b6 Sort the input dataframe by the given columns, either ascending or descending. Parameters: Name Type Description Default sort_by Iterable[str] Either a single column speified as a string or a list or tuple of columns to sort by required ascending bool Whether to sort ascending or descending. Boolean. Default: True True named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. Source code in finrules/backends/pandas/basic.py class SortRule ( UnaryOpBaseRule ): \"\"\" Sort the input dataframe by the given columns, either ascending or descending. Args: sort_by: Either a single column speified as a string or a list or tuple of columns to sort by ascending: Whether to sort ascending or descending. Boolean. Default: True named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Note: When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. \"\"\" def __init__ ( self , sort_by : Iterable [ str ], ascending : bool = True , named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . sort_by = [ col for col in sort_by ] if isinstance ( self . sort_by , str ): self . sort_by = [ self . sort_by ] assert isinstance ( ascending , bool ) or ( isinstance ( ascending , ( list , tuple )) and all ( isinstance ( val , bool ) for val in ascending ) and len ( ascending ) == len ( self . sort_by )), \"ascending must be a bool or a list of bool of the same len as sort_by\" self . ascending = ascending def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) df = df . sort_values ( by = self . sort_by , ascending = self . ascending , ignore_index = True ) self . _set_output_df ( data , df ) concat \u00b6 HConcatRule ( BinaryOpBaseRule ) \u00b6 Horizontally concatenates two dataframe with the result having the columns from the left dataframe followed by the columns from the right dataframe. The columns from the left dataframe will be followed by the columns from the right dataframe in the result dataframe. The two dataframes must not have columns with the same name. Example:: 1 2 3 4 5 6 7 8 9 10 11 Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | C | D | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: 1 2 3 4 | A | B | C | D | | a | 1 | d | 4 | | b | 2 | e | 5 | | c | 3 | f | 6 | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/concat.py class HConcatRule ( BinaryOpBaseRule ): \"\"\" Horizontally concatenates two dataframe with the result having the columns from the left dataframe followed by the columns from the right dataframe. The columns from the left dataframe will be followed by the columns from the right dataframe in the result dataframe. The two dataframes must not have columns with the same name. Example:: Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | C | D | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: | A | B | C | D | | a | 1 | d | 4 | | b | 2 | e | 5 | | c | 3 | f | 6 | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: ColumnAlreadyExistsError is raised if the two dataframes have columns with the same name. SchemaError is raised in strict mode only if the two dataframes have different number of rows. \"\"\" def apply ( self , data ): super () . apply ( data ) left_df = self . _get_input_df_left ( data ) right_df = self . _get_input_df_right ( data ) overlapping_names = set ( left_df . columns ) & set ( right_df . columns ) if overlapping_names : raise ColumnAlreadyExistsError ( f \"Column(s) { overlapping_names } exist in both dataframes.\" ) if self . strict : if len ( left_df ) != len ( right_df ): raise SchemaError ( f \"HConcat needs the two dataframe to have the same number of rows. left df= { len ( left_df ) } rows, right df= { len ( right_df ) } rows.\" ) df = concat ([ left_df , right_df ], axis = 1 ) self . _set_output_df ( data , df ) VConcatRule ( BinaryOpBaseRule ) \u00b6 Vertically concatenates two dataframe with the result having the rows from the left dataframe followed by the rows from the right dataframe. The rows of the right dataframe are added at the bottom of the rows from the left dataframe in the result dataframe. Example:: 1 2 3 4 5 6 7 8 9 10 11 Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | A | B | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: 1 2 3 4 5 6 7 | A | B | | a | 1 | | b | 2 | | c | 3 | | d | 4 | | e | 5 | | f | 6 | Parameters: Name Type Description Default named_input_left Optional[str] Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Optional[str] Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required subset_columns Optional[Iterable[str]] A subset list of columns available in both dataframes. Only these columns will be concated. The effect is similar to doing a ProjectRule(subset_columns) on both dataframes before the concat. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note In strict mode, as described above, SchemaError is raised if the columns are not the same (names, types can be inferred). In non-strict mode, columns are not checked and values are filled with NA when missing. Source code in finrules/backends/pandas/concat.py class VConcatRule ( BinaryOpBaseRule ): \"\"\" Vertically concatenates two dataframe with the result having the rows from the left dataframe followed by the rows from the right dataframe. The rows of the right dataframe are added at the bottom of the rows from the left dataframe in the result dataframe. Example:: Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | A | B | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: | A | B | | a | 1 | | b | 2 | | c | 3 | | d | 4 | | e | 5 | | f | 6 | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. subset_columns: A subset list of columns available in both dataframes. Only these columns will be concated. The effect is similar to doing a ProjectRule(subset_columns) on both dataframes before the concat. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any subset columns specified are missing from any of the dataframe. SchemaError is raised in strict mode only if the columns differ between the two dataframes and subset_columns is not specified. Note: In strict mode, as described above, SchemaError is raised if the columns are not the same (names, types can be inferred). In non-strict mode, columns are not checked and values are filled with NA when missing. \"\"\" def __init__ ( self , named_input_left : Optional [ str ], named_input_right : Optional [ str ], subset_columns : Optional [ Iterable [ str ]] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input_left = named_input_left , named_input_right = named_input_right , named_output = named_output , name = name , description = description , strict = strict ) self . subset_columns = [ col for col in subset_columns ] if subset_columns is not None else None def apply ( self , data ): super () . apply ( data ) left_df = self . _get_input_df_left ( data ) right_df = self . _get_input_df_right ( data ) if self . subset_columns : if not set ( self . subset_columns ) <= set ( left_df . columns ): raise MissingColumnError ( f \"Missing columns in the left dataframe of the concat operation: { set ( self . subset_columns ) - set ( left_df . columns ) } \" ) if not set ( self . subset_columns ) <= set ( right_df . columns ): raise MissingColumnError ( f \"Missing columns in the right dataframe of the concat operation: { set ( self . subset_columns ) - set ( right_df . columns ) } \" ) left_df = left_df [ self . subset_columns ] right_df = right_df [ self . subset_columns ] if self . strict : if set ( left_df . columns ) != set ( right_df . columns ): raise SchemaError ( f \"VConcat needs both dataframe have the same schema. Missing columns in the right df: { set ( right_df . columns ) - set ( left_df . columns ) } . Missing columns in the left df: { set ( left_df . columns ) - set ( right_df . columns ) } \" ) df = concat ([ left_df , right_df ], axis = 0 , ignore_index = True ) self . _set_output_df ( data , df ) fill \u00b6 BackFillRule ( BaseFillRule ) \u00b6 Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class BackFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"bfill\" ForwardFillRule ( BaseFillRule ) \u00b6 Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class ForwardFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"ffill\" joins \u00b6 InnerJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style inner join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 | A | B | C | | 1 | a | c | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class InnerJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style inner join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"inner\" LeftJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 2 | b | NA | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class LeftJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"left\" OuterJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 4 | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class OuterJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"outer\" RightJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 3 | NA | d | Note A right join is equivalent to a left join with the dataframes inverted, ie: left_df right_df is equivalent to right_df left_df although the order of the rows will be different. Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class RightJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 3 | NA | d | Note: A right join is equivalent to a left join with the dataframes inverted, ie: left_df <left_join> right_df is equivalent to right_df <right_join> left_df although the order of the rows will be different. Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"right\" newcolumns \u00b6 AddNewColumnRule ( UnaryOpBaseRule ) \u00b6 Adds a new column and sets it to the value of an evaluated expression. Example:: 1 2 3 4 5 Given df: | A | B | | 1 | 2 | | 2 | 3 | | 3 | 4 | AddNewColumnRule(\"Sum\", \"df['A'] + df['B']\").apply(df) Result:: 1 2 3 4 | A | B | Sum | | 1 | 2 | 3 | | 2 | 3 | 5 | | 3 | 4 | 7 | Parameters: Name Type Description Default column_nae The name of the new column to be added. required column_expression str An expression that gets evaluated and produces the value for the new column. The syntax: df[\"EXISTING_COL\"] can be used in the expression to refer to other columns in the dataframe. required named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note The implementation will try to use dataframe operations for performance, but when those are not supported it will fallback to row level operations. Note NA are treated slightly differently between dataframe level operations and row level. At dataframe level operations, NAs in operations will make the result be NA. In row level operations, NAs will generally raise a TypeError. To avoid such behavior, fill the NAs before performing operations. Source code in finrules/backends/pandas/newcolumns.py class AddNewColumnRule ( UnaryOpBaseRule ): \"\"\" Adds a new column and sets it to the value of an evaluated expression. Example:: Given df: | A | B | | 1 | 2 | | 2 | 3 | | 3 | 4 | > AddNewColumnRule(\"Sum\", \"df['A'] + df['B']\").apply(df) Result:: | A | B | Sum | | 1 | 2 | 3 | | 2 | 3 | 5 | | 3 | 4 | 7 | Args: column_nae: The name of the new column to be added. column_expression: An expression that gets evaluated and produces the value for the new column. The syntax: df[\"EXISTING_COL\"] can be used in the expression to refer to other columns in the dataframe. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: ColumnAlreadyExistsError is raised in strict mode only if a column with the same name already exists in the dataframe. AddNewColumnSyntaxError is raised if the column expression has a Python syntax error. A variety of Python exceptions can be raised when evaluating the expression, e.g.: - TypeError is raised if an operation is not supported between the types involved - NameError is raised if an unknown variable is used - KeyError is raised if you try to use an unknown column (i.e. df['ANY_UNKNOWN_COLUMN']) Note: The implementation will try to use dataframe operations for performance, but when those are not supported it will fallback to row level operations. Note: NA are treated slightly differently between dataframe level operations and row level. At dataframe level operations, NAs in operations will make the result be NA. In row level operations, NAs will generally raise a TypeError. To avoid such behavior, fill the NAs before performing operations. \"\"\" EXCLUDE_FROM_COMPARE = ( '_ast_expr' , '_compiled_expr' ) def __init__ ( self , column_name : str , column_expression : str , named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . column_name = column_name self . column_expression = column_expression try : self . _ast_expr = ast . parse ( self . column_expression , filename = f ' { self . column_name } _expression.py' , mode = 'eval' ) self . _compiled_expr = compile ( self . _ast_expr , filename = f ' { self . column_name } _expression.py' , mode = 'eval' ) except SyntaxError as exc : raise AddNewColumnSyntaxError ( f \"Error in expression ' { self . column_expression } ': { str ( exc ) } \" ) def apply ( self , data ): df = self . _get_input_df ( data ) if self . strict and self . column_name in df . columns : raise ColumnAlreadyExistsError ( f \"Column { self . column_name } already exists in the input dataframe.\" ) try : result = eval ( self . _compiled_expr , {}, { 'df' : df }) except TypeError : # attempt to run a slower apply expr = self . _compiled_expr result = df . apply ( lambda df : eval ( expr , {}, { 'df' : df }), axis = 1 ) df = df . assign ( ** { self . column_name : result }) self . _set_output_df ( data , df ) types \u00b6 TypeConversionRule ( UnaryOpBaseRule ) \u00b6 Converts the type of a given set of columns to other types. Parameters: Name Type Description Default mapper Mapping[str, str] A dict with columns names as keys and the new types as values. required named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/types.py class TypeConversionRule ( UnaryOpBaseRule ): \"\"\" Converts the type of a given set of columns to other types. Args: mapper: A dict with columns names as keys and the new types as values. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised when a column specified in the mapper doesn't exist in the input data frame. UnsupportedTypeError is raised when an unknown type is speified in the values of the mapper. \"\"\" SUPPORTED_TYPES = { 'int32' , 'int64' , 'float64' , 'str' , } def __init__ ( self , mapper : Mapping [ str , str ], named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {column_name:type}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {column_name:type} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) columns_set = set ( df . columns ) for column_name , type_str in self . mapper . items (): if column_name not in columns_set : raise MissingColumnError ( f \"Column ' { column_name } ' is missing in the data frame. Available columns: { sorted ( columns_set ) } \" ) if type_str not in self . SUPPORTED_TYPES : raise UnsupportedTypeError ( f \"Type ' { type_str } ' for column ' { column_name } ' is not currently supported.\" ) df = df . assign ( ** { column_name : df [ column_name ] . astype ( type_str ) for column_name , type_str in self . mapper . items ()}) self . _set_output_df ( data , df ) exceptions \u00b6 AddNewColumnSyntaxError ( SyntaxError ) \u00b6 A column is created but there is a syntax error in the column expression. Source code in finrules/exceptions.py class AddNewColumnSyntaxError ( SyntaxError ): \"\"\" A column is created but there is a syntax error in the column expression. \"\"\" ColumnAlreadyExistsError ( Exception ) \u00b6 An attempt to create a column that already exists in the dataframe. Source code in finrules/exceptions.py class ColumnAlreadyExistsError ( Exception ): \"\"\" An attempt to create a column that already exists in the dataframe. \"\"\" MissingColumnError ( Exception ) \u00b6 An operation is being applied to a column that is not present in the input data frame. Source code in finrules/exceptions.py class MissingColumnError ( Exception ): \"\"\" An operation is being applied to a column that is not present in the input data frame. \"\"\" SchemaError ( Exception ) \u00b6 An operation needs a certain schema for the dataframe which is not present. Source code in finrules/exceptions.py class SchemaError ( Exception ): \"\"\" An operation needs a certain schema for the dataframe which is not present. \"\"\" UnsupportedTypeError ( Exception ) \u00b6 A type conversion is attempted to a type that is not supported. Source code in finrules/exceptions.py class UnsupportedTypeError ( Exception ): \"\"\" A type conversion is attempted to a type that is not supported. \"\"\" rule \u00b6 BinaryOpBaseRule ( BaseRule ) \u00b6 Base class for binary operation rules (ie operations taking two data frames as input). Source code in finrules/rule.py class BinaryOpBaseRule ( BaseRule ): \"\"\" Base class for binary operation rules (ie operations taking two data frames as input). \"\"\" def __init__ ( self , named_input_left , named_input_right , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input_left is None or isinstance ( named_input_left , str ) and named_input_left assert named_input_right is None or isinstance ( named_input_right , str ) and named_input_right assert named_input_left != named_input_right self . named_input_left = named_input_left self . named_input_right = named_input_right def _get_input_df_left ( self , data ): if self . named_input_left is None : return data . get_main_output () return data . get_named_output ( self . named_input_left ) def _get_input_df_right ( self , data ): if self . named_input_right is None : return data . get_main_output () return data . get_named_output ( self . named_input_right ) UnaryOpBaseRule ( BaseRule ) \u00b6 Base class for unary operation rules (ie operations taking a single data frame as input). Source code in finrules/rule.py class UnaryOpBaseRule ( BaseRule ): \"\"\" Base class for unary operation rules (ie operations taking a single data frame as input). \"\"\" def __init__ ( self , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input is None or isinstance ( named_input , str ) and named_input self . named_input = named_input def _get_input_df ( self , data ): if self . named_input is None : return data . get_main_output () return data . get_named_output ( self . named_input )","title":"API Reference"},{"location":"api/#finrules.backends","text":"","title":"backends"},{"location":"api/#finrules.backends.common","text":"","title":"common"},{"location":"api/#finrules.backends.common.basic","text":"","title":"basic"},{"location":"api/#finrules.backends.common.basic.RulesBlock","text":"Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Parameters: Name Type Description Default rules Iterable[finrules.rule.BaseRule] An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). required Common params: !!! named_input \"Which dataframe to use as the input. Optional.\" When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. !!! named_output \"Give the output of this rule a name so it can be used by another rule as a named input. Optional.\" When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. !!! name \"Give the rule a name. Optional.\" Named rules are more descriptive as to what they're trying to do/the intent. !!! description \"Describe in detail what the rules does, how it does it. Optional.\" Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Source code in finrules/backends/common/basic.py class RulesBlock ( UnaryOpBaseRule ): \"\"\" Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Params: rules: An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). Common params: named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True \"\"\" def __init__ ( self , rules : Iterable [ BaseRule ], named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): self . _rules = [ rule for rule in rules ] assert self . _rules , \"RulesBlock: Empty rules set provided.\" assert all ( isinstance ( rule , BaseRule ) for rule in self . _rules ), [ rule for rule in self . _rules if not isinstance ( rule , BaseRule )] assert self . _rules [ 0 ] . named_input is None , \"First rule in a RulesBlock must consume the main input/output\" assert self . _rules [ - 1 ] . named_input is None , \"Last rule in a RulesBlock must produce the main output\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) def apply ( self , data ): super () . apply ( data ) data2 = RuleData ( main_input = self . _get_input_df ( data ), named_inputs = { k : v for k , v in data . get_named_outputs ()}, strict = self . strict ) for rule in self . _rules : rule . apply ( data2 ) self . _set_output_df ( data , data2 . get_main_output ()) def to_dict ( self ): dct = super () . to_dict () dct [ self . __class__ . __name__ ][ \"rules\" ] = [ rule . to_dict () for rule in self . _rules ] return dct @classmethod def from_dict ( cls , dct , backend ): dct = dct [ \"RulesBlock\" ] rules = [ BaseRule . from_dict ( rule , backend ) for rule in dct . get ( \"rules\" , ())] kwargs = { k : v for k , v in dct . items () if k != \"rules\" } return cls ( rules = rules , ** kwargs )","title":"RulesBlock"},{"location":"api/#finrules.backends.pandas","text":"","title":"pandas"},{"location":"api/#finrules.backends.pandas.basic","text":"","title":"basic"},{"location":"api/#finrules.backends.pandas.basic.DedupeRule","text":"De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Parameters: Name Type Description Default columns Iterable[str] A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. required keep Literal['first', 'last', 'none'] What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates 'first' named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note MissingColumnError is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. Source code in finrules/backends/pandas/basic.py class DedupeRule ( UnaryOpBaseRule ): \"\"\" De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Args: columns: A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. keep: What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised when a column specified to deduplicate on doesn't exist in the input data frame. Note: MissingColumnError is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. \"\"\" KEEP_FIRST = 'first' KEEP_LAST = 'last' KEEP_NONE = 'none' ALL_KEEPS = ( KEEP_FIRST , KEEP_LAST , KEEP_NONE ) def __init__ ( self , columns : Iterable [ str ], keep : Literal [ KEEP_FIRST , KEEP_LAST , KEEP_NONE ] = KEEP_FIRST , named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . columns = [ col for col in columns ] assert all ( isinstance ( col , str ) for col in self . columns ), \"DedupeRule: columns must be strings\" assert keep in self . ALL_KEEPS , f \"DedupeRule: keep must be one of: { self . ALL_KEEPS } \" self . keep = False if keep == DedupeRule . KEEP_NONE else keep def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if not set ( self . columns ) <= set ( df . columns ): raise MissingColumnError ( f \"Missing column(s) to dedupe on: { set ( self . columns ) - set ( df . columns ) } \" ) df = df . drop_duplicates ( subset = self . columns , keep = self . keep , ignore_index = True ) self . _set_output_df ( data , df )","title":"DedupeRule"},{"location":"api/#finrules.backends.pandas.basic.ProjectRule","text":"Reshapes the data frame to keep, eliminate or re-order the set of columns. Parameters: Name Type Description Default columns The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required exclude When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumnError exception is raised. In non strict mode, the missing columns are ignored. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/basic.py class ProjectRule ( BaseProjectRule , PandasRuleValidationMixin ): \"\"\" Reshapes the data frame to keep, eliminate or re-order the set of columns. Args: columns: The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. exclude: When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumnError exception is raised. In non strict mode, the missing columns are ignored. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised in strict mode only, if any columns are missing from the input data frame. \"\"\" def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) remaining_columns = self . _get_remaining_columns ( df . columns ) df = df [ remaining_columns ] self . _set_output_df ( data , df )","title":"ProjectRule"},{"location":"api/#finrules.backends.pandas.basic.RenameRule","text":"Renames a set of columns in the data frame. Parameters: Name Type Description Default mapper Mapping[str, str] A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/basic.py class RenameRule ( UnaryOpBaseRule ): \"\"\" Renames a set of columns in the data frame. Args: mapper: A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised in strict mode only, if any columns (keys) are missing from the input data frame. \"\"\" def __init__ ( self , mapper : Mapping [ str , str ], named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {old_name:new_name}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {old_name:new_name} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if self . strict : if not set ( self . mapper . keys ()) <= set ( df . columns ): raise MissingColumnError ( f \"Missing columns to rename: { set ( self . mapper . keys ()) - set ( df . columns ) } \" ) df = df . rename ( columns = self . mapper ) self . _set_output_df ( data , df )","title":"RenameRule"},{"location":"api/#finrules.backends.pandas.basic.SortRule","text":"Sort the input dataframe by the given columns, either ascending or descending. Parameters: Name Type Description Default sort_by Iterable[str] Either a single column speified as a string or a list or tuple of columns to sort by required ascending bool Whether to sort ascending or descending. Boolean. Default: True True named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. Source code in finrules/backends/pandas/basic.py class SortRule ( UnaryOpBaseRule ): \"\"\" Sort the input dataframe by the given columns, either ascending or descending. Args: sort_by: Either a single column speified as a string or a list or tuple of columns to sort by ascending: Whether to sort ascending or descending. Boolean. Default: True named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Note: When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. \"\"\" def __init__ ( self , sort_by : Iterable [ str ], ascending : bool = True , named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . sort_by = [ col for col in sort_by ] if isinstance ( self . sort_by , str ): self . sort_by = [ self . sort_by ] assert isinstance ( ascending , bool ) or ( isinstance ( ascending , ( list , tuple )) and all ( isinstance ( val , bool ) for val in ascending ) and len ( ascending ) == len ( self . sort_by )), \"ascending must be a bool or a list of bool of the same len as sort_by\" self . ascending = ascending def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) df = df . sort_values ( by = self . sort_by , ascending = self . ascending , ignore_index = True ) self . _set_output_df ( data , df )","title":"SortRule"},{"location":"api/#finrules.backends.pandas.concat","text":"","title":"concat"},{"location":"api/#finrules.backends.pandas.concat.HConcatRule","text":"Horizontally concatenates two dataframe with the result having the columns from the left dataframe followed by the columns from the right dataframe. The columns from the left dataframe will be followed by the columns from the right dataframe in the result dataframe. The two dataframes must not have columns with the same name. Example:: 1 2 3 4 5 6 7 8 9 10 11 Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | C | D | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: 1 2 3 4 | A | B | C | D | | a | 1 | d | 4 | | b | 2 | e | 5 | | c | 3 | f | 6 | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/concat.py class HConcatRule ( BinaryOpBaseRule ): \"\"\" Horizontally concatenates two dataframe with the result having the columns from the left dataframe followed by the columns from the right dataframe. The columns from the left dataframe will be followed by the columns from the right dataframe in the result dataframe. The two dataframes must not have columns with the same name. Example:: Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | C | D | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: | A | B | C | D | | a | 1 | d | 4 | | b | 2 | e | 5 | | c | 3 | f | 6 | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: ColumnAlreadyExistsError is raised if the two dataframes have columns with the same name. SchemaError is raised in strict mode only if the two dataframes have different number of rows. \"\"\" def apply ( self , data ): super () . apply ( data ) left_df = self . _get_input_df_left ( data ) right_df = self . _get_input_df_right ( data ) overlapping_names = set ( left_df . columns ) & set ( right_df . columns ) if overlapping_names : raise ColumnAlreadyExistsError ( f \"Column(s) { overlapping_names } exist in both dataframes.\" ) if self . strict : if len ( left_df ) != len ( right_df ): raise SchemaError ( f \"HConcat needs the two dataframe to have the same number of rows. left df= { len ( left_df ) } rows, right df= { len ( right_df ) } rows.\" ) df = concat ([ left_df , right_df ], axis = 1 ) self . _set_output_df ( data , df )","title":"HConcatRule"},{"location":"api/#finrules.backends.pandas.concat.VConcatRule","text":"Vertically concatenates two dataframe with the result having the rows from the left dataframe followed by the rows from the right dataframe. The rows of the right dataframe are added at the bottom of the rows from the left dataframe in the result dataframe. Example:: 1 2 3 4 5 6 7 8 9 10 11 Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | A | B | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: 1 2 3 4 5 6 7 | A | B | | a | 1 | | b | 2 | | c | 3 | | d | 4 | | e | 5 | | f | 6 | Parameters: Name Type Description Default named_input_left Optional[str] Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Optional[str] Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required subset_columns Optional[Iterable[str]] A subset list of columns available in both dataframes. Only these columns will be concated. The effect is similar to doing a ProjectRule(subset_columns) on both dataframes before the concat. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note In strict mode, as described above, SchemaError is raised if the columns are not the same (names, types can be inferred). In non-strict mode, columns are not checked and values are filled with NA when missing. Source code in finrules/backends/pandas/concat.py class VConcatRule ( BinaryOpBaseRule ): \"\"\" Vertically concatenates two dataframe with the result having the rows from the left dataframe followed by the rows from the right dataframe. The rows of the right dataframe are added at the bottom of the rows from the left dataframe in the result dataframe. Example:: Left dataframe: | A | B | | a | 1 | | b | 2 | | c | 3 | Right dataframe: | A | B | | d | 4 | | e | 5 | | f | 6 | After a concat(left, right), the result will look like:: | A | B | | a | 1 | | b | 2 | | c | 3 | | d | 4 | | e | 5 | | f | 6 | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. subset_columns: A subset list of columns available in both dataframes. Only these columns will be concated. The effect is similar to doing a ProjectRule(subset_columns) on both dataframes before the concat. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any subset columns specified are missing from any of the dataframe. SchemaError is raised in strict mode only if the columns differ between the two dataframes and subset_columns is not specified. Note: In strict mode, as described above, SchemaError is raised if the columns are not the same (names, types can be inferred). In non-strict mode, columns are not checked and values are filled with NA when missing. \"\"\" def __init__ ( self , named_input_left : Optional [ str ], named_input_right : Optional [ str ], subset_columns : Optional [ Iterable [ str ]] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input_left = named_input_left , named_input_right = named_input_right , named_output = named_output , name = name , description = description , strict = strict ) self . subset_columns = [ col for col in subset_columns ] if subset_columns is not None else None def apply ( self , data ): super () . apply ( data ) left_df = self . _get_input_df_left ( data ) right_df = self . _get_input_df_right ( data ) if self . subset_columns : if not set ( self . subset_columns ) <= set ( left_df . columns ): raise MissingColumnError ( f \"Missing columns in the left dataframe of the concat operation: { set ( self . subset_columns ) - set ( left_df . columns ) } \" ) if not set ( self . subset_columns ) <= set ( right_df . columns ): raise MissingColumnError ( f \"Missing columns in the right dataframe of the concat operation: { set ( self . subset_columns ) - set ( right_df . columns ) } \" ) left_df = left_df [ self . subset_columns ] right_df = right_df [ self . subset_columns ] if self . strict : if set ( left_df . columns ) != set ( right_df . columns ): raise SchemaError ( f \"VConcat needs both dataframe have the same schema. Missing columns in the right df: { set ( right_df . columns ) - set ( left_df . columns ) } . Missing columns in the left df: { set ( left_df . columns ) - set ( right_df . columns ) } \" ) df = concat ([ left_df , right_df ], axis = 0 , ignore_index = True ) self . _set_output_df ( data , df )","title":"VConcatRule"},{"location":"api/#finrules.backends.pandas.fill","text":"","title":"fill"},{"location":"api/#finrules.backends.pandas.fill.BackFillRule","text":"Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class BackFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"bfill\"","title":"BackFillRule"},{"location":"api/#finrules.backends.pandas.fill.ForwardFillRule","text":"Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class ForwardFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"ffill\"","title":"ForwardFillRule"},{"location":"api/#finrules.backends.pandas.joins","text":"","title":"joins"},{"location":"api/#finrules.backends.pandas.joins.InnerJoinRule","text":"Performs a database-style inner join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 | A | B | C | | 1 | a | c | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class InnerJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style inner join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"inner\"","title":"InnerJoinRule"},{"location":"api/#finrules.backends.pandas.joins.LeftJoinRule","text":"Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 2 | b | NA | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class LeftJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"left\"","title":"LeftJoinRule"},{"location":"api/#finrules.backends.pandas.joins.OuterJoinRule","text":"Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 4 | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class OuterJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"outer\"","title":"OuterJoinRule"},{"location":"api/#finrules.backends.pandas.joins.RightJoinRule","text":"Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 3 | NA | d | Note A right join is equivalent to a left join with the dataframes inverted, ie: left_df right_df is equivalent to right_df left_df although the order of the rows will be different. Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class RightJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 3 | NA | d | Note: A right join is equivalent to a left join with the dataframes inverted, ie: left_df <left_join> right_df is equivalent to right_df <right_join> left_df although the order of the rows will be different. Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"right\"","title":"RightJoinRule"},{"location":"api/#finrules.backends.pandas.newcolumns","text":"","title":"newcolumns"},{"location":"api/#finrules.backends.pandas.newcolumns.AddNewColumnRule","text":"Adds a new column and sets it to the value of an evaluated expression. Example:: 1 2 3 4 5 Given df: | A | B | | 1 | 2 | | 2 | 3 | | 3 | 4 | AddNewColumnRule(\"Sum\", \"df['A'] + df['B']\").apply(df) Result:: 1 2 3 4 | A | B | Sum | | 1 | 2 | 3 | | 2 | 3 | 5 | | 3 | 4 | 7 | Parameters: Name Type Description Default column_nae The name of the new column to be added. required column_expression str An expression that gets evaluated and produces the value for the new column. The syntax: df[\"EXISTING_COL\"] can be used in the expression to refer to other columns in the dataframe. required named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Note The implementation will try to use dataframe operations for performance, but when those are not supported it will fallback to row level operations. Note NA are treated slightly differently between dataframe level operations and row level. At dataframe level operations, NAs in operations will make the result be NA. In row level operations, NAs will generally raise a TypeError. To avoid such behavior, fill the NAs before performing operations. Source code in finrules/backends/pandas/newcolumns.py class AddNewColumnRule ( UnaryOpBaseRule ): \"\"\" Adds a new column and sets it to the value of an evaluated expression. Example:: Given df: | A | B | | 1 | 2 | | 2 | 3 | | 3 | 4 | > AddNewColumnRule(\"Sum\", \"df['A'] + df['B']\").apply(df) Result:: | A | B | Sum | | 1 | 2 | 3 | | 2 | 3 | 5 | | 3 | 4 | 7 | Args: column_nae: The name of the new column to be added. column_expression: An expression that gets evaluated and produces the value for the new column. The syntax: df[\"EXISTING_COL\"] can be used in the expression to refer to other columns in the dataframe. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: ColumnAlreadyExistsError is raised in strict mode only if a column with the same name already exists in the dataframe. AddNewColumnSyntaxError is raised if the column expression has a Python syntax error. A variety of Python exceptions can be raised when evaluating the expression, e.g.: - TypeError is raised if an operation is not supported between the types involved - NameError is raised if an unknown variable is used - KeyError is raised if you try to use an unknown column (i.e. df['ANY_UNKNOWN_COLUMN']) Note: The implementation will try to use dataframe operations for performance, but when those are not supported it will fallback to row level operations. Note: NA are treated slightly differently between dataframe level operations and row level. At dataframe level operations, NAs in operations will make the result be NA. In row level operations, NAs will generally raise a TypeError. To avoid such behavior, fill the NAs before performing operations. \"\"\" EXCLUDE_FROM_COMPARE = ( '_ast_expr' , '_compiled_expr' ) def __init__ ( self , column_name : str , column_expression : str , named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . column_name = column_name self . column_expression = column_expression try : self . _ast_expr = ast . parse ( self . column_expression , filename = f ' { self . column_name } _expression.py' , mode = 'eval' ) self . _compiled_expr = compile ( self . _ast_expr , filename = f ' { self . column_name } _expression.py' , mode = 'eval' ) except SyntaxError as exc : raise AddNewColumnSyntaxError ( f \"Error in expression ' { self . column_expression } ': { str ( exc ) } \" ) def apply ( self , data ): df = self . _get_input_df ( data ) if self . strict and self . column_name in df . columns : raise ColumnAlreadyExistsError ( f \"Column { self . column_name } already exists in the input dataframe.\" ) try : result = eval ( self . _compiled_expr , {}, { 'df' : df }) except TypeError : # attempt to run a slower apply expr = self . _compiled_expr result = df . apply ( lambda df : eval ( expr , {}, { 'df' : df }), axis = 1 ) df = df . assign ( ** { self . column_name : result }) self . _set_output_df ( data , df )","title":"AddNewColumnRule"},{"location":"api/#finrules.backends.pandas.types","text":"","title":"types"},{"location":"api/#finrules.backends.pandas.types.TypeConversionRule","text":"Converts the type of a given set of columns to other types. Parameters: Name Type Description Default mapper Mapping[str, str] A dict with columns names as keys and the new types as values. required named_input Optional[str] Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Optional[str] Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Optional[str] Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Optional[str] Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict bool When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/types.py class TypeConversionRule ( UnaryOpBaseRule ): \"\"\" Converts the type of a given set of columns to other types. Args: mapper: A dict with columns names as keys and the new types as values. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumnError is raised when a column specified in the mapper doesn't exist in the input data frame. UnsupportedTypeError is raised when an unknown type is speified in the values of the mapper. \"\"\" SUPPORTED_TYPES = { 'int32' , 'int64' , 'float64' , 'str' , } def __init__ ( self , mapper : Mapping [ str , str ], named_input : Optional [ str ] = None , named_output : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , strict : bool = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {column_name:type}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {column_name:type} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) columns_set = set ( df . columns ) for column_name , type_str in self . mapper . items (): if column_name not in columns_set : raise MissingColumnError ( f \"Column ' { column_name } ' is missing in the data frame. Available columns: { sorted ( columns_set ) } \" ) if type_str not in self . SUPPORTED_TYPES : raise UnsupportedTypeError ( f \"Type ' { type_str } ' for column ' { column_name } ' is not currently supported.\" ) df = df . assign ( ** { column_name : df [ column_name ] . astype ( type_str ) for column_name , type_str in self . mapper . items ()}) self . _set_output_df ( data , df )","title":"TypeConversionRule"},{"location":"api/#finrules.exceptions","text":"","title":"exceptions"},{"location":"api/#finrules.exceptions.AddNewColumnSyntaxError","text":"A column is created but there is a syntax error in the column expression. Source code in finrules/exceptions.py class AddNewColumnSyntaxError ( SyntaxError ): \"\"\" A column is created but there is a syntax error in the column expression. \"\"\"","title":"AddNewColumnSyntaxError"},{"location":"api/#finrules.exceptions.ColumnAlreadyExistsError","text":"An attempt to create a column that already exists in the dataframe. Source code in finrules/exceptions.py class ColumnAlreadyExistsError ( Exception ): \"\"\" An attempt to create a column that already exists in the dataframe. \"\"\"","title":"ColumnAlreadyExistsError"},{"location":"api/#finrules.exceptions.MissingColumnError","text":"An operation is being applied to a column that is not present in the input data frame. Source code in finrules/exceptions.py class MissingColumnError ( Exception ): \"\"\" An operation is being applied to a column that is not present in the input data frame. \"\"\"","title":"MissingColumnError"},{"location":"api/#finrules.exceptions.SchemaError","text":"An operation needs a certain schema for the dataframe which is not present. Source code in finrules/exceptions.py class SchemaError ( Exception ): \"\"\" An operation needs a certain schema for the dataframe which is not present. \"\"\"","title":"SchemaError"},{"location":"api/#finrules.exceptions.UnsupportedTypeError","text":"A type conversion is attempted to a type that is not supported. Source code in finrules/exceptions.py class UnsupportedTypeError ( Exception ): \"\"\" A type conversion is attempted to a type that is not supported. \"\"\"","title":"UnsupportedTypeError"},{"location":"api/#finrules.rule","text":"","title":"rule"},{"location":"api/#finrules.rule.BinaryOpBaseRule","text":"Base class for binary operation rules (ie operations taking two data frames as input). Source code in finrules/rule.py class BinaryOpBaseRule ( BaseRule ): \"\"\" Base class for binary operation rules (ie operations taking two data frames as input). \"\"\" def __init__ ( self , named_input_left , named_input_right , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input_left is None or isinstance ( named_input_left , str ) and named_input_left assert named_input_right is None or isinstance ( named_input_right , str ) and named_input_right assert named_input_left != named_input_right self . named_input_left = named_input_left self . named_input_right = named_input_right def _get_input_df_left ( self , data ): if self . named_input_left is None : return data . get_main_output () return data . get_named_output ( self . named_input_left ) def _get_input_df_right ( self , data ): if self . named_input_right is None : return data . get_main_output () return data . get_named_output ( self . named_input_right )","title":"BinaryOpBaseRule"},{"location":"api/#finrules.rule.UnaryOpBaseRule","text":"Base class for unary operation rules (ie operations taking a single data frame as input). Source code in finrules/rule.py class UnaryOpBaseRule ( BaseRule ): \"\"\" Base class for unary operation rules (ie operations taking a single data frame as input). \"\"\" def __init__ ( self , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input is None or isinstance ( named_input , str ) and named_input self . named_input = named_input def _get_input_df ( self , data ): if self . named_input is None : return data . get_main_output () return data . get_named_output ( self . named_input )","title":"UnaryOpBaseRule"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Ciprian Miclaus https://github.com/ciprianmiclaus Contributors \u00b6 None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Ciprian Miclaus https://github.com/ciprianmiclaus","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/ciprianmiclaus/finrules/issues. If you are reporting a bug, please include: Your operating system name and version. Python version, pandas version Any other details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug (a test case is ideal). Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 Finrules could always use more documentation, whether as part of the official Finrules docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/ciprianmiclaus/finrules/issues. If you are proposing a feature: Start with the problem statement (the pain point, what problem are you trying to solve) Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up finrules for local development. Fork the finrules repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/finrules.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/ciprianmiclaus/finrules/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_finrules ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/ciprianmiclaus/finrules/issues. If you are reporting a bug, please include: Your operating system name and version. Python version, pandas version Any other details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug (a test case is ideal).","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"Finrules could always use more documentation, whether as part of the official Finrules docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/ciprianmiclaus/finrules/issues. If you are proposing a feature: Start with the problem statement (the pain point, what problem are you trying to solve) Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up finrules for local development. Fork the finrules repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/finrules.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/ciprianmiclaus/finrules/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_finrules ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.1.0 (2023-09-07) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2023-09-07","text":"First release on PyPI.","title":"0.1.0 (2023-09-07)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install Finrules, run this command in your terminal: 1 pip install finrules This is the preferred method to install Finrules, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Finrules can be downloaded from the Github repo . You can either clone the public repository: 1 git clone git://github.com/ciprianmiclaus/finrules Or download the tarball : 1 curl -OJL https://github.com/ciprianmiclaus/finrules/tarball/master Once you have a copy of the source, you can install it with: 1 pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install Finrules, run this command in your terminal: 1 pip install finrules This is the preferred method to install Finrules, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for Finrules can be downloaded from the Github repo . You can either clone the public repository: 1 git clone git://github.com/ciprianmiclaus/finrules Or download the tarball : 1 curl -OJL https://github.com/ciprianmiclaus/finrules/tarball/master Once you have a copy of the source, you can install it with: 1 pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use Finrules in a project 1 import finrules","title":"Usage"},{"location":"usage/#usage","text":"To use Finrules in a project 1 import finrules","title":"Usage"}]}