{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Finrules \u00b6 A python rule engine operating with data frames aimed at the financial services Free software: MIT Documentation: https://ciprianmiclaus.github.io/finrules/ Features \u00b6 TODO Credits \u00b6 This package was created with the ppw tool. For more information, please visit the project page .","title":"Home"},{"location":"#finrules","text":"A python rule engine operating with data frames aimed at the financial services Free software: MIT Documentation: https://ciprianmiclaus.github.io/finrules/","title":"Finrules"},{"location":"#features","text":"TODO","title":"Features"},{"location":"#credits","text":"This package was created with the ppw tool. For more information, please visit the project page .","title":"Credits"},{"location":"api/","text":"Top-level package for Finrules. backends special \u00b6 common special \u00b6 basic \u00b6 RulesBlock ( UnaryOpBaseRule ) \u00b6 Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Parameters: Name Type Description Default rules An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). required Common params: !!! named_input \"Which dataframe to use as the input. Optional.\" When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. !!! named_output \"Give the output of this rule a name so it can be used by another rule as a named input. Optional.\" When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. !!! name \"Give the rule a name. Optional.\" Named rules are more descriptive as to what they're trying to do/the intent. !!! description \"Describe in detail what the rules does, how it does it. Optional.\" Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Source code in finrules/backends/common/basic.py class RulesBlock ( UnaryOpBaseRule ): \"\"\" Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Params: rules: An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). Common params: named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True \"\"\" def __init__ ( self , rules , named_input = None , named_output = None , name = None , description = None , strict = True ): self . _rules = [ rule for rule in rules ] assert self . _rules , \"RulesBlock: Empty rules set provided.\" assert all ( isinstance ( rule , BaseRule ) for rule in self . _rules ), [ rule for rule in self . _rules if not isinstance ( rule , BaseRule )] assert self . _rules [ 0 ] . named_input is None , \"First rule in a RulesBlock must consume the main input/output\" assert self . _rules [ - 1 ] . named_input is None , \"Last rule in a RulesBlock must produce the main output\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) def apply ( self , data ): super () . apply ( data ) data2 = RuleData ( main_input = self . _get_input_df ( data ), named_inputs = { k : v for k , v in data . get_named_outputs ()}, strict = self . strict ) for rule in self . _rules : rule . apply ( data2 ) self . _set_output_df ( data , data2 . get_main_output ()) def to_dict ( self ): dct = super () . to_dict () dct [ self . __class__ . __name__ ][ \"rules\" ] = [ rule . to_dict () for rule in self . _rules ] return dct @classmethod def from_dict ( cls , dct , backend ): dct = dct [ \"RulesBlock\" ] rules = [ BaseRule . from_dict ( rule , backend ) for rule in dct . get ( \"rules\" , ())] kwargs = { k : v for k , v in dct . items () if k != \"rules\" } return cls ( rules = rules , ** kwargs ) pandas special \u00b6 basic \u00b6 DedupeRule ( UnaryOpBaseRule ) \u00b6 De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Parameters: Name Type Description Default columns A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. required keep What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates 'first' named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Note MissingColumn is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. Source code in finrules/backends/pandas/basic.py class DedupeRule ( UnaryOpBaseRule ): \"\"\" De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Args: columns: A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. keep: What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised when a column specified to deduplicate on doesn't exist in the input data frame. Note: MissingColumn is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. \"\"\" KEEP_FIRST = 'first' KEEP_LAST = 'last' KEEP_NONE = 'none' ALL_KEEPS = ( KEEP_FIRST , KEEP_LAST , KEEP_NONE ) def __init__ ( self , columns , keep = KEEP_FIRST , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . columns = [ col for col in columns ] assert all ( isinstance ( col , str ) for col in self . columns ), \"DedupeRule: columns must be strings\" assert keep in self . ALL_KEEPS , f \"DedupeRule: keep must be one of: { self . ALL_KEEPS } \" self . keep = False if keep == DedupeRule . KEEP_NONE else keep def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if not set ( self . columns ) <= set ( df . columns ): raise MissingColumn ( f \"Missing column(s) to dedupe on: { set ( self . columns ) - set ( df . columns ) } \" ) df = df . drop_duplicates ( subset = self . columns , keep = self . keep , ignore_index = True ) self . _set_output_df ( data , df ) ProjectRule ( BaseProjectRule , PandasRuleValidationMixin ) \u00b6 Reshapes the data frame to keep, eliminate or re-order the set of columns. Parameters: Name Type Description Default columns The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required exclude When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumn exception is raised. In non strict mode, the missing columns are ignored. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/basic.py class ProjectRule ( BaseProjectRule , PandasRuleValidationMixin ): \"\"\" Reshapes the data frame to keep, eliminate or re-order the set of columns. Args: columns: The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. exclude: When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumn exception is raised. In non strict mode, the missing columns are ignored. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised in strict mode only, if any columns are missing from the input data frame. \"\"\" def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) remaining_columns = self . _get_remaining_columns ( df . columns ) df = df [ remaining_columns ] self . _set_output_df ( data , df ) RenameRule ( UnaryOpBaseRule ) \u00b6 Renames a set of columns in the data frame. Parameters: Name Type Description Default mapper A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/basic.py class RenameRule ( UnaryOpBaseRule ): \"\"\" Renames a set of columns in the data frame. Args: mapper: A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised in strict mode only, if any columns (keys) are missing from the input data frame. \"\"\" def __init__ ( self , mapper , named_input = None , named_output = None , name = None , description = None , strict = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {old_name:new_name}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {old_name:new_name} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if self . strict : if not set ( self . mapper . keys ()) <= set ( df . columns ): raise MissingColumn ( f \"Missing columns to rename: { set ( self . mapper . keys ()) - set ( df . columns ) } \" ) df = df . rename ( columns = self . mapper ) self . _set_output_df ( data , df ) SortRule ( UnaryOpBaseRule ) \u00b6 Sort the input dataframe by the given columns, either ascending or descending. Parameters: Name Type Description Default sort_by Either a single column speified as a string or a list or tuple of columns to sort by required ascending Whether to sort ascending or descending. Boolean. Default: True True named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Note When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. Source code in finrules/backends/pandas/basic.py class SortRule ( UnaryOpBaseRule ): \"\"\" Sort the input dataframe by the given columns, either ascending or descending. Args: sort_by: Either a single column speified as a string or a list or tuple of columns to sort by ascending: Whether to sort ascending or descending. Boolean. Default: True named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Note: When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. \"\"\" def __init__ ( self , sort_by , ascending = True , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) assert sort_by and ( isinstance ( sort_by , str ) or ( isinstance ( sort_by , ( list , tuple )) and all ( isinstance ( val , str ) for val in sort_by ))), \"sort_by must be a str (single column) or a list of str (multiple columns)\" self . sort_by = sort_by if isinstance ( self . sort_by , str ): self . sort_by = [ self . sort_by ] assert isinstance ( ascending , bool ) or ( isinstance ( ascending , ( list , tuple )) and all ( isinstance ( val , bool ) for val in ascending ) and len ( ascending ) == len ( self . sort_by )), \"ascending must be a bool or a list of bool of the same len as sort_by\" self . ascending = ascending def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) df = df . sort_values ( by = self . sort_by , ascending = self . ascending , ignore_index = True ) self . _set_output_df ( data , df ) fill \u00b6 BackFillRule ( BaseFillRule ) \u00b6 Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class BackFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"bfill\" ForwardFillRule ( BaseFillRule ) \u00b6 Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class ForwardFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"ffill\" joins \u00b6 InnerJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style inner join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 | A | B | C | | 1 | a | c | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class InnerJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style inner join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"inner\" LeftJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 2 | b | NA | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class LeftJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"left\" OuterJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 4 | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class OuterJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"outer\" RightJoinRule ( BaseJoinRule ) \u00b6 Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 3 | NA | d | Note A right join is equivalent to a left join with the dataframes inverted, ie: left_df right_df is equivalent to right_df left_df although the order of the rows will be different. Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class RightJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 3 | NA | d | Note: A right join is equivalent to a left join with the dataframes inverted, ie: left_df <left_join> right_df is equivalent to right_df <right_join> left_df although the order of the rows will be different. Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"right\" types \u00b6 TypeConversionRule ( UnaryOpBaseRule ) \u00b6 Converts the type of a given set of columns to other types. Parameters: Name Type Description Default mapper A dict with columns names as keys and the new types as values. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/types.py class TypeConversionRule ( UnaryOpBaseRule ): \"\"\" Converts the type of a given set of columns to other types. Args: mapper: A dict with columns names as keys and the new types as values. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised when a column specified in the mapper doesn't exist in the input data frame. UnsupportedType is raised when an unknown type is speified in the values of the mapper. \"\"\" SUPPORTED_TYPES = { 'int32' , 'int64' , 'float64' , 'str' , } def __init__ ( self , mapper , named_input = None , named_output = None , name = None , description = None , strict = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {column_name:type}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {column_name:type} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) columns_set = set ( df . columns ) for column_name , type_str in self . mapper . items (): if column_name not in columns_set : raise MissingColumn ( f \"Column ' { column_name } ' is missing in the data frame. Available columns: { sorted ( columns_set ) } \" ) if type_str not in self . SUPPORTED_TYPES : raise UnsupportedType ( f \"Type ' { type_str } ' for column ' { column_name } ' is not currently supported.\" ) df [ column_name ] = df [ column_name ] . astype ( type_str ) self . _set_output_df ( data , df ) exceptions \u00b6 MissingColumn ( Exception ) \u00b6 An operation is being applied to a column that is not present in the input data frame. Source code in finrules/exceptions.py class MissingColumn ( Exception ): \"\"\" An operation is being applied to a column that is not present in the input data frame. \"\"\" UnsupportedType ( Exception ) \u00b6 A type conversion is attempted to a type that is not supported. Source code in finrules/exceptions.py class UnsupportedType ( Exception ): \"\"\" A type conversion is attempted to a type that is not supported. \"\"\" rule \u00b6 BinaryOpBaseRule ( BaseRule ) \u00b6 Base class for binary operation rules (ie operations taking two data frames as input). Source code in finrules/rule.py class BinaryOpBaseRule ( BaseRule ): \"\"\" Base class for binary operation rules (ie operations taking two data frames as input). \"\"\" def __init__ ( self , named_input_left , named_input_right , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input_left is None or isinstance ( named_input_left , str ) and named_input_left assert named_input_right is None or isinstance ( named_input_right , str ) and named_input_right assert named_input_left != named_input_right self . named_input_left = named_input_left self . named_input_right = named_input_right def _get_input_df_left ( self , data ): if self . named_input_left is None : return data . get_main_output () return data . get_named_output ( self . named_input_left ) def _get_input_df_right ( self , data ): if self . named_input_right is None : return data . get_main_output () return data . get_named_output ( self . named_input_right ) UnaryOpBaseRule ( BaseRule ) \u00b6 Base class for unary operation rules (ie operations taking a single data frame as input). Source code in finrules/rule.py class UnaryOpBaseRule ( BaseRule ): \"\"\" Base class for unary operation rules (ie operations taking a single data frame as input). \"\"\" def __init__ ( self , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input is None or isinstance ( named_input , str ) and named_input self . named_input = named_input def _get_input_df ( self , data ): if self . named_input is None : return data . get_main_output () return data . get_named_output ( self . named_input )","title":"API Reference"},{"location":"api/#finrules.backends","text":"","title":"backends"},{"location":"api/#finrules.backends.common","text":"","title":"common"},{"location":"api/#finrules.backends.common.basic","text":"","title":"basic"},{"location":"api/#finrules.backends.common.basic.RulesBlock","text":"Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Parameters: Name Type Description Default rules An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). required Common params: !!! named_input \"Which dataframe to use as the input. Optional.\" When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. !!! named_output \"Give the output of this rule a name so it can be used by another rule as a named input. Optional.\" When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. !!! name \"Give the rule a name. Optional.\" Named rules are more descriptive as to what they're trying to do/the intent. !!! description \"Describe in detail what the rules does, how it does it. Optional.\" Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Source code in finrules/backends/common/basic.py class RulesBlock ( UnaryOpBaseRule ): \"\"\" Groups rules into encapsulated blocks or units of rules that achieve one thing. Blocks are reusable and encapsulated to reduce complexity. Params: rules: An iterable of rules which are part of this block. The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule). The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block). Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation). Common params: named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True \"\"\" def __init__ ( self , rules , named_input = None , named_output = None , name = None , description = None , strict = True ): self . _rules = [ rule for rule in rules ] assert self . _rules , \"RulesBlock: Empty rules set provided.\" assert all ( isinstance ( rule , BaseRule ) for rule in self . _rules ), [ rule for rule in self . _rules if not isinstance ( rule , BaseRule )] assert self . _rules [ 0 ] . named_input is None , \"First rule in a RulesBlock must consume the main input/output\" assert self . _rules [ - 1 ] . named_input is None , \"Last rule in a RulesBlock must produce the main output\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) def apply ( self , data ): super () . apply ( data ) data2 = RuleData ( main_input = self . _get_input_df ( data ), named_inputs = { k : v for k , v in data . get_named_outputs ()}, strict = self . strict ) for rule in self . _rules : rule . apply ( data2 ) self . _set_output_df ( data , data2 . get_main_output ()) def to_dict ( self ): dct = super () . to_dict () dct [ self . __class__ . __name__ ][ \"rules\" ] = [ rule . to_dict () for rule in self . _rules ] return dct @classmethod def from_dict ( cls , dct , backend ): dct = dct [ \"RulesBlock\" ] rules = [ BaseRule . from_dict ( rule , backend ) for rule in dct . get ( \"rules\" , ())] kwargs = { k : v for k , v in dct . items () if k != \"rules\" } return cls ( rules = rules , ** kwargs )","title":"RulesBlock"},{"location":"api/#finrules.backends.pandas","text":"","title":"pandas"},{"location":"api/#finrules.backends.pandas.basic","text":"","title":"basic"},{"location":"api/#finrules.backends.pandas.basic.DedupeRule","text":"De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Parameters: Name Type Description Default columns A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. required keep What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates 'first' named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Note MissingColumn is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. Source code in finrules/backends/pandas/basic.py class DedupeRule ( UnaryOpBaseRule ): \"\"\" De-duplicates by dropping duplicates using a set of columns to determine the duplicates. It has logic to keep the first, last or none of the duplicate in a set of duplicates. Args: columns: A subset of columns in the data frame which are used to determine the set of duplicates. Any rows that have the same values in these columns are considered to be duplicates. keep: What to keep in the de-duplication process. One of: first: keeps the first row in the duplicate set last: keeps the last row in the duplicate set none: drops all the duplicates named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised when a column specified to deduplicate on doesn't exist in the input data frame. Note: MissingColumn is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns. \"\"\" KEEP_FIRST = 'first' KEEP_LAST = 'last' KEEP_NONE = 'none' ALL_KEEPS = ( KEEP_FIRST , KEEP_LAST , KEEP_NONE ) def __init__ ( self , columns , keep = KEEP_FIRST , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . columns = [ col for col in columns ] assert all ( isinstance ( col , str ) for col in self . columns ), \"DedupeRule: columns must be strings\" assert keep in self . ALL_KEEPS , f \"DedupeRule: keep must be one of: { self . ALL_KEEPS } \" self . keep = False if keep == DedupeRule . KEEP_NONE else keep def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if not set ( self . columns ) <= set ( df . columns ): raise MissingColumn ( f \"Missing column(s) to dedupe on: { set ( self . columns ) - set ( df . columns ) } \" ) df = df . drop_duplicates ( subset = self . columns , keep = self . keep , ignore_index = True ) self . _set_output_df ( data , df )","title":"DedupeRule"},{"location":"api/#finrules.backends.pandas.basic.ProjectRule","text":"Reshapes the data frame to keep, eliminate or re-order the set of columns. Parameters: Name Type Description Default columns The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required exclude When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumn exception is raised. In non strict mode, the missing columns are ignored. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/basic.py class ProjectRule ( BaseProjectRule , PandasRuleValidationMixin ): \"\"\" Reshapes the data frame to keep, eliminate or re-order the set of columns. Args: columns: The list of columns to keep or eliminate from the data frame. The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. exclude: When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumn exception is raised. In non strict mode, the missing columns are ignored. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised in strict mode only, if any columns are missing from the input data frame. \"\"\" def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) remaining_columns = self . _get_remaining_columns ( df . columns ) df = df [ remaining_columns ] self . _set_output_df ( data , df )","title":"ProjectRule"},{"location":"api/#finrules.backends.pandas.basic.RenameRule","text":"Renames a set of columns in the data frame. Parameters: Name Type Description Default mapper A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/basic.py class RenameRule ( UnaryOpBaseRule ): \"\"\" Renames a set of columns in the data frame. Args: mapper: A dictionary of old names (keys) and new names (values) to be used for the rename operation The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised in strict mode only, if any columns (keys) are missing from the input data frame. \"\"\" def __init__ ( self , mapper , named_input = None , named_output = None , name = None , description = None , strict = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {old_name:new_name}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {old_name:new_name} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) if self . strict : if not set ( self . mapper . keys ()) <= set ( df . columns ): raise MissingColumn ( f \"Missing columns to rename: { set ( self . mapper . keys ()) - set ( df . columns ) } \" ) df = df . rename ( columns = self . mapper ) self . _set_output_df ( data , df )","title":"RenameRule"},{"location":"api/#finrules.backends.pandas.basic.SortRule","text":"Sort the input dataframe by the given columns, either ascending or descending. Parameters: Name Type Description Default sort_by Either a single column speified as a string or a list or tuple of columns to sort by required ascending Whether to sort ascending or descending. Boolean. Default: True True named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Note When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. Source code in finrules/backends/pandas/basic.py class SortRule ( UnaryOpBaseRule ): \"\"\" Sort the input dataframe by the given columns, either ascending or descending. Args: sort_by: Either a single column speified as a string or a list or tuple of columns to sort by ascending: Whether to sort ascending or descending. Boolean. Default: True named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Note: When multiple columns are specified, the first column decides the sort order. For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on. \"\"\" def __init__ ( self , sort_by , ascending = True , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) assert sort_by and ( isinstance ( sort_by , str ) or ( isinstance ( sort_by , ( list , tuple )) and all ( isinstance ( val , str ) for val in sort_by ))), \"sort_by must be a str (single column) or a list of str (multiple columns)\" self . sort_by = sort_by if isinstance ( self . sort_by , str ): self . sort_by = [ self . sort_by ] assert isinstance ( ascending , bool ) or ( isinstance ( ascending , ( list , tuple )) and all ( isinstance ( val , bool ) for val in ascending ) and len ( ascending ) == len ( self . sort_by )), \"ascending must be a bool or a list of bool of the same len as sort_by\" self . ascending = ascending def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) df = df . sort_values ( by = self . sort_by , ascending = self . ascending , ignore_index = True ) self . _set_output_df ( data , df )","title":"SortRule"},{"location":"api/#finrules.backends.pandas.fill","text":"","title":"fill"},{"location":"api/#finrules.backends.pandas.fill.BackFillRule","text":"Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class BackFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | NA | | b | 2 | | a | NA | After a fill forward:: | A | B | | a | 2 | | b | 2 | | a | NA | After a fill forward with group_by=[\"A\"]:: | A | B | | a | NA | | b | 2 | | a | NA | The \"a\" group has no non-NA value, so it is not filled. The \"b\" group has a non-NA value of 2 but not other NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"bfill\"","title":"BackFillRule"},{"location":"api/#finrules.backends.pandas.fill.ForwardFillRule","text":"Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: 1 2 3 4 | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: 1 2 3 4 | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Parameters: Name Type Description Default columns The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. required sort_by The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. required sort_ascending When sort_by is specified, True means sort ascending, False sort descending. required group_by The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/fill.py class ForwardFillRule ( BaseFillRule ): \"\"\" Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data. Example:: | A | B | | a | 1 | | b | NA | | a | NA | After a fill forward:: | A | B | | a | 1 | | b | 1 | | a | 1 | After a fill forward with group_by=[\"A\"]:: | A | B | | a | 1 | | b | NA | | a | 1 | The \"a\" group has the first non-NA value as 1 and that is used \"forward\" to fill the 3rd row. The \"b\" group has no non-NA values, so nothing to fill. Args: columns: The list of columns to replaces NAs for. The rest of the columns in the dataframe are not affected. sort_by: The list of columns to sort by before the fill operation. Optional. Given the previous non-NA values are used, sorting can make a difference in the values uses. sort_ascending: When sort_by is specified, True means sort ascending, False sort descending. group_by: The list of columns to group by before the fill operation. Optional. The fill values are only used within a group, other adjacent groups are not filled. Useful when you want to copy(fill) data at a certain group level. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe. \"\"\" FILL_METHOD = \"ffill\"","title":"ForwardFillRule"},{"location":"api/#finrules.backends.pandas.joins","text":"","title":"joins"},{"location":"api/#finrules.backends.pandas.joins.InnerJoinRule","text":"Performs a database-style inner join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 | A | B | C | | 1 | a | c | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class InnerJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style inner join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An inner join specifies that only those rows that have key values in both left and right will be copied over and merged into the result data frame. Any rows without corresponding values on the other side (be it left or right) will be dropped from the result. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"inner\"","title":"InnerJoinRule"},{"location":"api/#finrules.backends.pandas.joins.LeftJoinRule","text":"Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 2 | b | NA | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class LeftJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A left join specifies that all the rows in the left dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the right dataframe. The right columns will be populated with NaNs/None when there is no corresponding row on the right. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"left\"","title":"LeftJoinRule"},{"location":"api/#finrules.backends.pandas.joins.OuterJoinRule","text":"Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 4 | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class OuterJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. An outer join specifies that all the rows in the both left and right dataframes will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the other dataframe. The missing side will have its columns populated with NA when the rows are missing. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 2 | b | NA | | 3 | NA | d | Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"outer\"","title":"OuterJoinRule"},{"location":"api/#finrules.backends.pandas.joins.RightJoinRule","text":"Performs a database-style left join operation on two data frames. A join involves two data frames left_df right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Examples: left dataframe:: 1 2 3 | A | B | | 1 | a | | 2 | b | right dataframe:: 1 2 3 | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: 1 2 3 | A | B | C | | 1 | a | c | | 3 | NA | d | Note A right join is equivalent to a left join with the dataframes inverted, ie: left_df right_df is equivalent to right_df left_df although the order of the rows will be different. Parameters: Name Type Description Default named_input_left Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required named_input_right Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. required key_columns_left A list or tuple of column names to join on (columns in the left data frame) required key_columns_right A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. required suffixes A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). required named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. required name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. required description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. required strict When set to True, the rule does a stricter valiation. Default: True required Source code in finrules/backends/pandas/joins.py class RightJoinRule ( BaseJoinRule ): \"\"\" Performs a database-style left join operation on two data frames. A join involves two data frames left_df <join> right_df with the result performing a database style join or a merge of the two, with the resulting columns coming from both dataframes. For example, if the left dataframe has two columns A, B and the right dataframe has two column A, C, and assuming A is the key column the result will have three columns A, B, C. The rows that have the same value in the key column A will be merged on the same row in the result dataframe. A right join specifies that all the rows in the right dataframe will be present in the result, irrespective of whether there's a corresponding row with the same values in the key columns in the left dataframe. The left columns will be populated with NA when there is no corresponding row on the left. Example: left dataframe:: | A | B | | 1 | a | | 2 | b | right dataframe:: | A | C | | 1 | c | | 3 | d | result (key columns=[\"A\"]):: | A | B | C | | 1 | a | c | | 3 | NA | d | Note: A right join is equivalent to a left join with the dataframes inverted, ie: left_df <left_join> right_df is equivalent to right_df <right_join> left_df although the order of the rows will be different. Args: named_input_left: Which dataframe to use as the input on the left side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. named_input_right: Which dataframe to use as the input on the right side of the join. When set to None, the input is taken from the main output of the previous rule. Set it to a string value, the name of an output dataframe of a previous rule. key_columns_left: A list or tuple of column names to join on (columns in the left data frame) key_columns_right: A list or tuple of column names to join on (columns in the right data frame). If not set or set to None, the key_columns_left is used on the right dataframe too. suffixes: A list or tuple of two values which will be set as suffixes for the columns in the result data frame for those columns that have the same name (and are not key columns). named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised if any columns (keys) are missing from any of the two input data frames. \"\"\" JOIN_TYPE = \"right\"","title":"RightJoinRule"},{"location":"api/#finrules.backends.pandas.types","text":"","title":"types"},{"location":"api/#finrules.backends.pandas.types.TypeConversionRule","text":"Converts the type of a given set of columns to other types. Parameters: Name Type Description Default mapper A dict with columns names as keys and the new types as values. required named_input Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. None named_output Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. None name Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. None description Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. None strict When set to True, the rule does a stricter valiation. Default: True True Source code in finrules/backends/pandas/types.py class TypeConversionRule ( UnaryOpBaseRule ): \"\"\" Converts the type of a given set of columns to other types. Args: mapper: A dict with columns names as keys and the new types as values. named_input: Which dataframe to use as the input. Optional. When not set, the input is taken from the main output. Set it to a string value, the name of an output dataframe of a previous rule. named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional. When not set, the result of this rule will be available as the main output. When set to a name (string), the result will be available as that named output. name: Give the rule a name. Optional. Named rules are more descriptive as to what they're trying to do/the intent. description: Describe in detail what the rules does, how it does it. Optional. Together with the name, the description acts as the documentation of the rule. strict: When set to True, the rule does a stricter valiation. Default: True Raises: MissingColumn is raised when a column specified in the mapper doesn't exist in the input data frame. UnsupportedType is raised when an unknown type is speified in the values of the mapper. \"\"\" SUPPORTED_TYPES = { 'int32' , 'int64' , 'float64' , 'str' , } def __init__ ( self , mapper , named_input = None , named_output = None , name = None , description = None , strict = True ): assert isinstance ( mapper , dict ), \"mapper needs to be a dict {column_name:type}\" assert all ( isinstance ( key , str ) and isinstance ( val , str ) for key , val in mapper . items ()), \"mapper needs to be a dict {column_name:type} where the names are str\" super () . __init__ ( named_input = named_input , named_output = named_output , name = name , description = description , strict = strict ) self . mapper = mapper def apply ( self , data ): super () . apply ( data ) df = self . _get_input_df ( data ) columns_set = set ( df . columns ) for column_name , type_str in self . mapper . items (): if column_name not in columns_set : raise MissingColumn ( f \"Column ' { column_name } ' is missing in the data frame. Available columns: { sorted ( columns_set ) } \" ) if type_str not in self . SUPPORTED_TYPES : raise UnsupportedType ( f \"Type ' { type_str } ' for column ' { column_name } ' is not currently supported.\" ) df [ column_name ] = df [ column_name ] . astype ( type_str ) self . _set_output_df ( data , df )","title":"TypeConversionRule"},{"location":"api/#finrules.exceptions","text":"","title":"exceptions"},{"location":"api/#finrules.exceptions.MissingColumn","text":"An operation is being applied to a column that is not present in the input data frame. Source code in finrules/exceptions.py class MissingColumn ( Exception ): \"\"\" An operation is being applied to a column that is not present in the input data frame. \"\"\"","title":"MissingColumn"},{"location":"api/#finrules.exceptions.UnsupportedType","text":"A type conversion is attempted to a type that is not supported. Source code in finrules/exceptions.py class UnsupportedType ( Exception ): \"\"\" A type conversion is attempted to a type that is not supported. \"\"\"","title":"UnsupportedType"},{"location":"api/#finrules.rule","text":"","title":"rule"},{"location":"api/#finrules.rule.BinaryOpBaseRule","text":"Base class for binary operation rules (ie operations taking two data frames as input). Source code in finrules/rule.py class BinaryOpBaseRule ( BaseRule ): \"\"\" Base class for binary operation rules (ie operations taking two data frames as input). \"\"\" def __init__ ( self , named_input_left , named_input_right , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input_left is None or isinstance ( named_input_left , str ) and named_input_left assert named_input_right is None or isinstance ( named_input_right , str ) and named_input_right assert named_input_left != named_input_right self . named_input_left = named_input_left self . named_input_right = named_input_right def _get_input_df_left ( self , data ): if self . named_input_left is None : return data . get_main_output () return data . get_named_output ( self . named_input_left ) def _get_input_df_right ( self , data ): if self . named_input_right is None : return data . get_main_output () return data . get_named_output ( self . named_input_right )","title":"BinaryOpBaseRule"},{"location":"api/#finrules.rule.UnaryOpBaseRule","text":"Base class for unary operation rules (ie operations taking a single data frame as input). Source code in finrules/rule.py class UnaryOpBaseRule ( BaseRule ): \"\"\" Base class for unary operation rules (ie operations taking a single data frame as input). \"\"\" def __init__ ( self , named_input = None , named_output = None , name = None , description = None , strict = True ): super () . __init__ ( named_output = named_output , name = name , description = description , strict = strict ) assert named_input is None or isinstance ( named_input , str ) and named_input self . named_input = named_input def _get_input_df ( self , data ): if self . named_input is None : return data . get_main_output () return data . get_named_output ( self . named_input )","title":"UnaryOpBaseRule"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Ciprian Miclaus https://github.com/ciprianmiclaus Contributors \u00b6 None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Ciprian Miclaus https://github.com/ciprianmiclaus","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/ciprianmiclaus/finrules/issues. If you are reporting a bug, please include: Your operating system name and version. Python version, pandas version Any other details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug (a test case is ideal). Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 Finrules could always use more documentation, whether as part of the official Finrules docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/ciprianmiclaus/finrules/issues. If you are proposing a feature: Start with the problem statement (the pain point, what problem are you trying to solve) Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up finrules for local development. Fork the finrules repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/finrules.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/ciprianmiclaus/finrules/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_finrules ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/ciprianmiclaus/finrules/issues. If you are reporting a bug, please include: Your operating system name and version. Python version, pandas version Any other details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug (a test case is ideal).","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"Finrules could always use more documentation, whether as part of the official Finrules docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/ciprianmiclaus/finrules/issues. If you are proposing a feature: Start with the problem statement (the pain point, what problem are you trying to solve) Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up finrules for local development. Fork the finrules repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/finrules.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/ciprianmiclaus/finrules/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_finrules ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.1.0 (2023-09-07) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2023-09-07","text":"First release on PyPI.","title":"0.1.0 (2023-09-07)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install Finrules, run this command in your terminal: 1 pip install finrules This is the preferred method to install Finrules, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Finrules can be downloaded from the Github repo . You can either clone the public repository: 1 git clone git://github.com/ciprianmiclaus/finrules Or download the tarball : 1 curl -OJL https://github.com/ciprianmiclaus/finrules/tarball/master Once you have a copy of the source, you can install it with: 1 pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install Finrules, run this command in your terminal: 1 pip install finrules This is the preferred method to install Finrules, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for Finrules can be downloaded from the Github repo . You can either clone the public repository: 1 git clone git://github.com/ciprianmiclaus/finrules Or download the tarball : 1 curl -OJL https://github.com/ciprianmiclaus/finrules/tarball/master Once you have a copy of the source, you can install it with: 1 pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use Finrules in a project 1 import finrules","title":"Usage"},{"location":"usage/#usage","text":"To use Finrules in a project 1 import finrules","title":"Usage"}]}