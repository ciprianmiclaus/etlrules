
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-8.1.11">
    
    
      
        <title>API Reference - ETLrules</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.50e68009.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.e6a45f82.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#etlrules" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-component="outdated" hidden>
        <aside class="md-banner md-banner--warning">
          
        </aside>
      </div>
    
    
      

  

<header class="md-header md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="ETLrules" class="md-header__button md-logo" aria-label="ETLrules" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ETLrules
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API Reference
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ciprianmiclaus/etlrules" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    etlrules
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href=".." class="md-tabs__link">
      Home
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../installation/" class="md-tabs__link">
      Installation
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../usage/" class="md-tabs__link">
      Usage
    </a>
  </li>

      
        
  
  
    
  


  <li class="md-tabs__item">
    <a href="./" class="md-tabs__link md-tabs__link--active">
      API Reference
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../contributing/" class="md-tabs__link">
      Contributing
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../authors/" class="md-tabs__link">
      Authors
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../history/" class="md-tabs__link">
      History
    </a>
  </li>

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="ETLrules" class="md-nav__button md-logo" aria-label="ETLrules" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    ETLrules
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ciprianmiclaus/etlrules" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    etlrules
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../installation/" class="md-nav__link">
        Installation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../usage/" class="md-nav__link">
        Usage
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          API Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        API Reference
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#etlrules" class="md-nav__link">
    etlrules
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.backends" class="md-nav__link">
    backends
  </a>
  
    <nav class="md-nav" aria-label="backends">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common" class="md-nav__link">
    common
  </a>
  
    <nav class="md-nav" aria-label="common">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.aggregate" class="md-nav__link">
    aggregate
  </a>
  
    <nav class="md-nav" aria-label="aggregate">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.aggregate.AggregateRule" class="md-nav__link">
    AggregateRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic" class="md-nav__link">
    basic
  </a>
  
    <nav class="md-nav" aria-label="basic">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.DedupeRule" class="md-nav__link">
    DedupeRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.ExplodeValuesRule" class="md-nav__link">
    ExplodeValuesRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.ProjectRule" class="md-nav__link">
    ProjectRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.RenameRule" class="md-nav__link">
    RenameRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.ReplaceRule" class="md-nav__link">
    ReplaceRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.RulesBlock" class="md-nav__link">
    RulesBlock
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.SortRule" class="md-nav__link">
    SortRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.concat" class="md-nav__link">
    concat
  </a>
  
    <nav class="md-nav" aria-label="concat">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.concat.HConcatRule" class="md-nav__link">
    HConcatRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.concat.VConcatRule" class="md-nav__link">
    VConcatRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.conditions" class="md-nav__link">
    conditions
  </a>
  
    <nav class="md-nav" aria-label="conditions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.conditions.FilterRule" class="md-nav__link">
    FilterRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.conditions.IfThenElseRule" class="md-nav__link">
    IfThenElseRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime" class="md-nav__link">
    datetime
  </a>
  
    <nav class="md-nav" aria-label="datetime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeAddRule" class="md-nav__link">
    DateTimeAddRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeDiffRule" class="md-nav__link">
    DateTimeDiffRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeExtractComponentRule" class="md-nav__link">
    DateTimeExtractComponentRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeLocalNowRule" class="md-nav__link">
    DateTimeLocalNowRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeRoundDownRule" class="md-nav__link">
    DateTimeRoundDownRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeRoundRule" class="md-nav__link">
    DateTimeRoundRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeRoundUpRule" class="md-nav__link">
    DateTimeRoundUpRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeSubstractRule" class="md-nav__link">
    DateTimeSubstractRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeToStrFormatRule" class="md-nav__link">
    DateTimeToStrFormatRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeUTCNowRule" class="md-nav__link">
    DateTimeUTCNowRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.fill" class="md-nav__link">
    fill
  </a>
  
    <nav class="md-nav" aria-label="fill">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.fill.BackFillRule" class="md-nav__link">
    BackFillRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.fill.ForwardFillRule" class="md-nav__link">
    ForwardFillRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io" class="md-nav__link">
    io
  </a>
  
    <nav class="md-nav" aria-label="io">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.db" class="md-nav__link">
    db
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.db.ReadSQLQueryRule" class="md-nav__link">
    ReadSQLQueryRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.db.WriteSQLTableRule" class="md-nav__link">
    WriteSQLTableRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files" class="md-nav__link">
    files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.ReadCSVFileRule" class="md-nav__link">
    ReadCSVFileRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.ReadParquetFileRule" class="md-nav__link">
    ReadParquetFileRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.WriteCSVFileRule" class="md-nav__link">
    WriteCSVFileRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.WriteParquetFileRule" class="md-nav__link">
    WriteParquetFileRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins" class="md-nav__link">
    joins
  </a>
  
    <nav class="md-nav" aria-label="joins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.InnerJoinRule" class="md-nav__link">
    InnerJoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.LeftJoinRule" class="md-nav__link">
    LeftJoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.OuterJoinRule" class="md-nav__link">
    OuterJoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.RightJoinRule" class="md-nav__link">
    RightJoinRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.newcolumns" class="md-nav__link">
    newcolumns
  </a>
  
    <nav class="md-nav" aria-label="newcolumns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.newcolumns.AddNewColumnRule" class="md-nav__link">
    AddNewColumnRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.newcolumns.AddRowNumbersRule" class="md-nav__link">
    AddRowNumbersRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.numeric" class="md-nav__link">
    numeric
  </a>
  
    <nav class="md-nav" aria-label="numeric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.numeric.AbsRule" class="md-nav__link">
    AbsRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.numeric.RoundRule" class="md-nav__link">
    RoundRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings" class="md-nav__link">
    strings
  </a>
  
    <nav class="md-nav" aria-label="strings">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrCapitalizeRule" class="md-nav__link">
    StrCapitalizeRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrExtractRule" class="md-nav__link">
    StrExtractRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrLowerRule" class="md-nav__link">
    StrLowerRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrPadRule" class="md-nav__link">
    StrPadRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrSplitRejoinRule" class="md-nav__link">
    StrSplitRejoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrSplitRule" class="md-nav__link">
    StrSplitRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrStripRule" class="md-nav__link">
    StrStripRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrUpperRule" class="md-nav__link">
    StrUpperRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.types" class="md-nav__link">
    types
  </a>
  
    <nav class="md-nav" aria-label="types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.types.TypeConversionRule" class="md-nav__link">
    TypeConversionRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.engine" class="md-nav__link">
    engine
  </a>
  
    <nav class="md-nav" aria-label="engine">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.engine.RuleEngine" class="md-nav__link">
    RuleEngine
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.exceptions" class="md-nav__link">
    exceptions
  </a>
  
    <nav class="md-nav" aria-label="exceptions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.ColumnAlreadyExistsError" class="md-nav__link">
    ColumnAlreadyExistsError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.ExpressionSyntaxError" class="md-nav__link">
    ExpressionSyntaxError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.GraphRuntimeError" class="md-nav__link">
    GraphRuntimeError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.InvalidPlanError" class="md-nav__link">
    InvalidPlanError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.MissingColumnError" class="md-nav__link">
    MissingColumnError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.SQLError" class="md-nav__link">
    SQLError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.SchemaError" class="md-nav__link">
    SchemaError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.UnsupportedTypeError" class="md-nav__link">
    UnsupportedTypeError
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.plan" class="md-nav__link">
    plan
  </a>
  
    <nav class="md-nav" aria-label="plan">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan" class="md-nav__link">
    Plan
  </a>
  
    <nav class="md-nav" aria-label="Plan">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.add_rule" class="md-nav__link">
    add_rule()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.from_dict" class="md-nav__link">
    from_dict()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.from_yaml" class="md-nav__link">
    from_yaml()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.get_mode" class="md-nav__link">
    get_mode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.get_rule" class="md-nav__link">
    get_rule()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.is_empty" class="md-nav__link">
    is_empty()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.to_dict" class="md-nav__link">
    to_dict()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.to_yaml" class="md-nav__link">
    to_yaml()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.rule" class="md-nav__link">
    rule
  </a>
  
    <nav class="md-nav" aria-label="rule">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.rule.BinaryOpBaseRule" class="md-nav__link">
    BinaryOpBaseRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.rule.UnaryOpBaseRule" class="md-nav__link">
    UnaryOpBaseRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.runner" class="md-nav__link">
    runner
  </a>
  
    <nav class="md-nav" aria-label="runner">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.runner.load_plan" class="md-nav__link">
    load_plan()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.runner.run_plan" class="md-nav__link">
    run_plan()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        Contributing
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../authors/" class="md-nav__link">
        Authors
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../history/" class="md-nav__link">
        History
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#etlrules" class="md-nav__link">
    etlrules
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.backends" class="md-nav__link">
    backends
  </a>
  
    <nav class="md-nav" aria-label="backends">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common" class="md-nav__link">
    common
  </a>
  
    <nav class="md-nav" aria-label="common">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.aggregate" class="md-nav__link">
    aggregate
  </a>
  
    <nav class="md-nav" aria-label="aggregate">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.aggregate.AggregateRule" class="md-nav__link">
    AggregateRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic" class="md-nav__link">
    basic
  </a>
  
    <nav class="md-nav" aria-label="basic">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.DedupeRule" class="md-nav__link">
    DedupeRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.ExplodeValuesRule" class="md-nav__link">
    ExplodeValuesRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.ProjectRule" class="md-nav__link">
    ProjectRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.RenameRule" class="md-nav__link">
    RenameRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.ReplaceRule" class="md-nav__link">
    ReplaceRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.RulesBlock" class="md-nav__link">
    RulesBlock
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.basic.SortRule" class="md-nav__link">
    SortRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.concat" class="md-nav__link">
    concat
  </a>
  
    <nav class="md-nav" aria-label="concat">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.concat.HConcatRule" class="md-nav__link">
    HConcatRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.concat.VConcatRule" class="md-nav__link">
    VConcatRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.conditions" class="md-nav__link">
    conditions
  </a>
  
    <nav class="md-nav" aria-label="conditions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.conditions.FilterRule" class="md-nav__link">
    FilterRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.conditions.IfThenElseRule" class="md-nav__link">
    IfThenElseRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime" class="md-nav__link">
    datetime
  </a>
  
    <nav class="md-nav" aria-label="datetime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeAddRule" class="md-nav__link">
    DateTimeAddRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeDiffRule" class="md-nav__link">
    DateTimeDiffRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeExtractComponentRule" class="md-nav__link">
    DateTimeExtractComponentRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeLocalNowRule" class="md-nav__link">
    DateTimeLocalNowRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeRoundDownRule" class="md-nav__link">
    DateTimeRoundDownRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeRoundRule" class="md-nav__link">
    DateTimeRoundRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeRoundUpRule" class="md-nav__link">
    DateTimeRoundUpRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeSubstractRule" class="md-nav__link">
    DateTimeSubstractRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeToStrFormatRule" class="md-nav__link">
    DateTimeToStrFormatRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.datetime.DateTimeUTCNowRule" class="md-nav__link">
    DateTimeUTCNowRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.fill" class="md-nav__link">
    fill
  </a>
  
    <nav class="md-nav" aria-label="fill">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.fill.BackFillRule" class="md-nav__link">
    BackFillRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.fill.ForwardFillRule" class="md-nav__link">
    ForwardFillRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io" class="md-nav__link">
    io
  </a>
  
    <nav class="md-nav" aria-label="io">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.db" class="md-nav__link">
    db
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.db.ReadSQLQueryRule" class="md-nav__link">
    ReadSQLQueryRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.db.WriteSQLTableRule" class="md-nav__link">
    WriteSQLTableRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files" class="md-nav__link">
    files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.ReadCSVFileRule" class="md-nav__link">
    ReadCSVFileRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.ReadParquetFileRule" class="md-nav__link">
    ReadParquetFileRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.WriteCSVFileRule" class="md-nav__link">
    WriteCSVFileRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.io.files.WriteParquetFileRule" class="md-nav__link">
    WriteParquetFileRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins" class="md-nav__link">
    joins
  </a>
  
    <nav class="md-nav" aria-label="joins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.InnerJoinRule" class="md-nav__link">
    InnerJoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.LeftJoinRule" class="md-nav__link">
    LeftJoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.OuterJoinRule" class="md-nav__link">
    OuterJoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.joins.RightJoinRule" class="md-nav__link">
    RightJoinRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.newcolumns" class="md-nav__link">
    newcolumns
  </a>
  
    <nav class="md-nav" aria-label="newcolumns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.newcolumns.AddNewColumnRule" class="md-nav__link">
    AddNewColumnRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.newcolumns.AddRowNumbersRule" class="md-nav__link">
    AddRowNumbersRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.numeric" class="md-nav__link">
    numeric
  </a>
  
    <nav class="md-nav" aria-label="numeric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.numeric.AbsRule" class="md-nav__link">
    AbsRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.numeric.RoundRule" class="md-nav__link">
    RoundRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings" class="md-nav__link">
    strings
  </a>
  
    <nav class="md-nav" aria-label="strings">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrCapitalizeRule" class="md-nav__link">
    StrCapitalizeRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrExtractRule" class="md-nav__link">
    StrExtractRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrLowerRule" class="md-nav__link">
    StrLowerRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrPadRule" class="md-nav__link">
    StrPadRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrSplitRejoinRule" class="md-nav__link">
    StrSplitRejoinRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrSplitRule" class="md-nav__link">
    StrSplitRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrStripRule" class="md-nav__link">
    StrStripRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.strings.StrUpperRule" class="md-nav__link">
    StrUpperRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.types" class="md-nav__link">
    types
  </a>
  
    <nav class="md-nav" aria-label="types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.backends.common.types.TypeConversionRule" class="md-nav__link">
    TypeConversionRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.engine" class="md-nav__link">
    engine
  </a>
  
    <nav class="md-nav" aria-label="engine">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.engine.RuleEngine" class="md-nav__link">
    RuleEngine
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.exceptions" class="md-nav__link">
    exceptions
  </a>
  
    <nav class="md-nav" aria-label="exceptions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.ColumnAlreadyExistsError" class="md-nav__link">
    ColumnAlreadyExistsError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.ExpressionSyntaxError" class="md-nav__link">
    ExpressionSyntaxError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.GraphRuntimeError" class="md-nav__link">
    GraphRuntimeError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.InvalidPlanError" class="md-nav__link">
    InvalidPlanError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.MissingColumnError" class="md-nav__link">
    MissingColumnError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.SQLError" class="md-nav__link">
    SQLError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.SchemaError" class="md-nav__link">
    SchemaError
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.exceptions.UnsupportedTypeError" class="md-nav__link">
    UnsupportedTypeError
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.plan" class="md-nav__link">
    plan
  </a>
  
    <nav class="md-nav" aria-label="plan">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan" class="md-nav__link">
    Plan
  </a>
  
    <nav class="md-nav" aria-label="Plan">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.add_rule" class="md-nav__link">
    add_rule()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.from_dict" class="md-nav__link">
    from_dict()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.from_yaml" class="md-nav__link">
    from_yaml()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.get_mode" class="md-nav__link">
    get_mode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.get_rule" class="md-nav__link">
    get_rule()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.is_empty" class="md-nav__link">
    is_empty()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.to_dict" class="md-nav__link">
    to_dict()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.plan.Plan.to_yaml" class="md-nav__link">
    to_yaml()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.rule" class="md-nav__link">
    rule
  </a>
  
    <nav class="md-nav" aria-label="rule">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.rule.BinaryOpBaseRule" class="md-nav__link">
    BinaryOpBaseRule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.rule.UnaryOpBaseRule" class="md-nav__link">
    UnaryOpBaseRule
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#etlrules.runner" class="md-nav__link">
    runner
  </a>
  
    <nav class="md-nav" aria-label="runner">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#etlrules.runner.load_plan" class="md-nav__link">
    load_plan()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etlrules.runner.run_plan" class="md-nav__link">
    run_plan()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
<a href="https://github.com/ciprianmiclaus/etlrules/edit/master/docs/api.md" title="Edit this page" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
</a>


  <h1>API Reference</h1>

<div class="doc doc-object doc-module">

<a id="etlrules"></a>
    <div class="doc doc-contents first">

      <p>Top-level package for ETLrules.</p>



  <div class="doc doc-children">














  <div class="doc doc-object doc-module">



<h2 id="etlrules.backends" class="doc doc-heading">
        <code>backends</code>


  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#etlrules.backends" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">










  <div class="doc doc-object doc-module">



<h3 id="etlrules.backends.common" class="doc doc-heading">
        <code>common</code>


  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#etlrules.backends.common" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">




  <div class="doc doc-children">










  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.aggregate" class="doc doc-heading">
        <code>aggregate</code>



<a href="#etlrules.backends.common.aggregate" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.aggregate.AggregateRule" class="doc doc-heading">
        <code>
AggregateRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.aggregate.AggregateRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Performs a SQL-like groupby and aggregation.</p>
<p>It takes a list of columns to group by and the result will have one row for each unique combination
of values in the group_by columns.
The rest of the columns (not in the group_by) can be aggregated using either pre-defined aggregations
or using custom python expressions.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>group_by</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>A list of columns to group the result by</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>aggregations</code></td>
        <td><code>Optional[Mapping[str, str]]</code></td>
        <td><p>A mapping {column_name: aggregation_function} which specifies how to aggregate
columns which are not in the group_by list.
The following list of aggregation functions are supported::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code>min: minimum of the values in the group
max: minimum of the values in the group
mean: The mathematical mean value in the group
count: How many values are in the group, including NA
countNoNA: How many values are in the group, excluding NA
sum: The sum of the values in the group
first: The first value in the group
last: The last value in the group
list: Produces a python list with all the values in the group, excluding NA
tuple: Like list above but produces a tuple
csv: Produces a comma separated string of values, exluding NA
</code></pre></div></td></tr></table></div></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>aggregation_expressions</code></td>
        <td><code>Optional[Mapping[str, str]]</code></td>
        <td><p>A mapping {column_name: aggregation_expression} which specifies how to aggregate
columns which are not in the group_by list.
The aggregation expression is a string representing a valid Python expression which gets evaluated.
The input will be in a variable <code>values</code>. <code>isnull</code> can be used to filter out NA.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>{&quot;C&quot;: &quot;&#39;;&#39;.join(str(v) for v in values if not isnull(v))&quot;}

The above aggregates the column C by producing a ; separated string of values in the group, excluding NA.
</code></pre></div></td></tr></table></div></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>aggregation_types</code></td>
        <td><code>Optional[Mapping[str, str]]</code></td>
        <td><p>An optional mapping of {column_name: column_type} which converts the respective output
column to the given type. The supported types are: int8, int16, int32, int64, uint8, uint16,
uint32, uint64, float32, float64, string, boolean, datetime and timedelta.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised if a column appears in multiple places in group_by/aggregations/aggregation_expressions.</p></td>
      </tr>
      <tr>
        <td><code>ExpressionSyntaxError</code></td>
        <td><p>raised if any aggregation expression (if any are passed in) has a Python syntax error.</p></td>
      </tr>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised in strict mode only if a column specified in aggregations or aggregation_expressions
is missing from the input dataframe. If aggregation_types are specified, it is raised in strict mode if a column
in the aggregation_types is missing from the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>UnsupportedTypeError</code></td>
        <td><p>raised if a type specified in aggregation_types is not supported.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raised if a column in aggregations is trying to be aggregated using an unknown aggregate function</p></td>
      </tr>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>raised if an operation is not supported between the types involved</p></td>
      </tr>
      <tr>
        <td><code>NameError</code></td>
        <td><p>raised if an unknown variable is used</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other Python exceptions can be raised when custom aggregation expressions are used, depending on what the expression is doing.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any columns not in the group_by list and not present in either aggregations or aggregation_expressions will be dropped from the result.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/aggregate.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">AggregateRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs a SQL-like groupby and aggregation.</span>

<span class="sd">    It takes a list of columns to group by and the result will have one row for each unique combination</span>
<span class="sd">    of values in the group_by columns.</span>
<span class="sd">    The rest of the columns (not in the group_by) can be aggregated using either pre-defined aggregations</span>
<span class="sd">    or using custom python expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        group_by: A list of columns to group the result by</span>
<span class="sd">        aggregations: A mapping {column_name: aggregation_function} which specifies how to aggregate</span>
<span class="sd">            columns which are not in the group_by list.</span>
<span class="sd">            The following list of aggregation functions are supported::</span>

<span class="sd">                min: minimum of the values in the group</span>
<span class="sd">                max: minimum of the values in the group</span>
<span class="sd">                mean: The mathematical mean value in the group</span>
<span class="sd">                count: How many values are in the group, including NA</span>
<span class="sd">                countNoNA: How many values are in the group, excluding NA</span>
<span class="sd">                sum: The sum of the values in the group</span>
<span class="sd">                first: The first value in the group</span>
<span class="sd">                last: The last value in the group</span>
<span class="sd">                list: Produces a python list with all the values in the group, excluding NA</span>
<span class="sd">                tuple: Like list above but produces a tuple</span>
<span class="sd">                csv: Produces a comma separated string of values, exluding NA</span>

<span class="sd">        aggregation_expressions: A mapping {column_name: aggregation_expression} which specifies how to aggregate</span>
<span class="sd">            columns which are not in the group_by list.</span>
<span class="sd">            The aggregation expression is a string representing a valid Python expression which gets evaluated.</span>
<span class="sd">            The input will be in a variable `values`. `isnull` can be used to filter out NA.</span>

<span class="sd">            Example::</span>

<span class="sd">                {&quot;C&quot;: &quot;&#39;;&#39;.join(str(v) for v in values if not isnull(v))&quot;}</span>

<span class="sd">                The above aggregates the column C by producing a ; separated string of values in the group, excluding NA.</span>

<span class="sd">        aggregation_types: An optional mapping of {column_name: column_type} which converts the respective output</span>
<span class="sd">            column to the given type. The supported types are: int8, int16, int32, int64, uint8, uint16,</span>
<span class="sd">            uint32, uint64, float32, float64, string, boolean, datetime and timedelta.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ColumnAlreadyExistsError: raised if a column appears in multiple places in group_by/aggregations/aggregation_expressions.</span>
<span class="sd">        ExpressionSyntaxError: raised if any aggregation expression (if any are passed in) has a Python syntax error.</span>
<span class="sd">        MissingColumnError: raised in strict mode only if a column specified in aggregations or aggregation_expressions</span>
<span class="sd">            is missing from the input dataframe. If aggregation_types are specified, it is raised in strict mode if a column</span>
<span class="sd">            in the aggregation_types is missing from the input dataframe.</span>
<span class="sd">        UnsupportedTypeError: raised if a type specified in aggregation_types is not supported.</span>
<span class="sd">        ValueError: raised if a column in aggregations is trying to be aggregated using an unknown aggregate function</span>
<span class="sd">        TypeError: raised if an operation is not supported between the types involved</span>
<span class="sd">        NameError: raised if an unknown variable is used</span>

<span class="sd">    Note:</span>
<span class="sd">        Other Python exceptions can be raised when custom aggregation expressions are used, depending on what the expression is doing.</span>

<span class="sd">    Note:</span>
<span class="sd">        Any columns not in the group_by list and not present in either aggregations or aggregation_expressions will be dropped from the result.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">AGGREGATIONS</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">EXCLUDE_FROM_COMPARE</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_aggs&quot;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group_by</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">aggregations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">aggregation_expressions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">aggregation_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">group_by</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">aggregations</span> <span class="ow">or</span> <span class="n">aggregation_expressions</span><span class="p">,</span> <span class="s2">&quot;One of aggregations or aggregation_expressions must be specified.&quot;</span>
        <span class="k">if</span> <span class="n">aggregations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregations</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">agg_func</span> <span class="ow">in</span> <span class="n">aggregations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ColumnAlreadyExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> appears in group_by and cannot be aggregated.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">agg_func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">AGGREGATIONS</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">agg_func</span><span class="si">}</span><span class="s2">&#39; is not a supported aggregation function.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aggregations</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">AGGREGATIONS</span><span class="p">[</span><span class="n">agg_func</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">agg_func</span> <span class="ow">in</span> <span class="p">(</span><span class="n">aggregations</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">})</span>
        <span class="k">if</span> <span class="n">aggregation_expressions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregation_expressions</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">agg_expr</span> <span class="ow">in</span> <span class="n">aggregation_expressions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ColumnAlreadyExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> appears in group_by and cannot be aggregated.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ColumnAlreadyExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> is already being aggregated.&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_ast_expr</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">agg_expr</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">_expression.py&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;eval&quot;</span><span class="p">)</span>
                    <span class="n">_compiled_expr</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">_ast_expr</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">_expression.py&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;eval&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">values</span><span class="p">,</span> <span class="n">bound_compiled_expr</span><span class="o">=</span><span class="n">_compiled_expr</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span>
                        <span class="n">bound_compiled_expr</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;isnull&quot;</span><span class="p">:</span> <span class="n">isnull</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">values</span><span class="p">}</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">SyntaxError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ExpressionSyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in aggregation expression for column &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39;: &#39;</span><span class="si">{</span><span class="n">agg_expr</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aggregation_expressions</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_expr</span>

        <span class="k">if</span> <span class="n">aggregation_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregation_types</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">col_type</span> <span class="ow">in</span> <span class="n">aggregation_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span> <span class="ow">and</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> is neither in the group by columns nor in the aggregations.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">col_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_TYPES</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">UnsupportedTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported type &#39;</span><span class="si">{</span><span class="n">col_type</span><span class="si">}</span><span class="s2">&#39; for column &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aggregation_types</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregation_types</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">do_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">aggs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df_columns_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">df_columns_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missimg columns to aggregate by: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">df_columns_set</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">aggs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">col</span><span class="p">:</span> <span class="n">agg</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">agg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df_columns_set</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aggs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggs</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_aggregate</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">aggs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">
















  </div>

    </div>

  </div>







  </div>

    </div>

  </div>




  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.basic" class="doc doc-heading">
        <code>basic</code>



<a href="#etlrules.backends.common.basic" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.basic.DedupeRule" class="doc doc-heading">
        <code>
DedupeRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.basic.DedupeRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>De-duplicates by dropping duplicates using a set of columns to determine the duplicates.</p>
<p>It has logic to keep the first, last or none of the duplicate in a set of duplicates.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>columns</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>A subset of columns in the data frame which are used to determine the set of duplicates.
Any rows that have the same values in these columns are considered to be duplicates.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>keep</code></td>
        <td><code>Literal[&#39;first&#39;, &#39;last&#39;, &#39;none&#39;]</code></td>
        <td><p>What to keep in the de-duplication process. One of:
first: keeps the first row in the duplicate set
last: keeps the last row in the duplicate set
none: drops all the duplicates</p></td>
        <td><code>&#39;first&#39;</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised when a column specified to deduplicate on doesn't exist in the input data frame.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>MissingColumnError is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/basic.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DedupeRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; De-duplicates by dropping duplicates using a set of columns to determine the duplicates.</span>

<span class="sd">    It has logic to keep the first, last or none of the duplicate in a set of duplicates.</span>

<span class="sd">    Args:</span>
<span class="sd">        columns: A subset of columns in the data frame which are used to determine the set of duplicates.</span>
<span class="sd">            Any rows that have the same values in these columns are considered to be duplicates.</span>
<span class="sd">        keep: What to keep in the de-duplication process. One of:</span>
<span class="sd">            first: keeps the first row in the duplicate set</span>
<span class="sd">            last: keeps the last row in the duplicate set</span>
<span class="sd">            none: drops all the duplicates</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised when a column specified to deduplicate on doesn&#39;t exist in the input data frame.</span>

<span class="sd">    Note:</span>
<span class="sd">        MissingColumnError is raised in both strict and non-strict modes. This is because the rule cannot operate reliably without a correct set of columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">KEEP_FIRST</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
    <span class="n">KEEP_LAST</span> <span class="o">=</span> <span class="s1">&#39;last&#39;</span>
    <span class="n">KEEP_NONE</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

    <span class="n">ALL_KEEPS</span> <span class="o">=</span> <span class="p">(</span><span class="n">KEEP_FIRST</span><span class="p">,</span> <span class="n">KEEP_LAST</span><span class="p">,</span> <span class="n">KEEP_NONE</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">KEEP_FIRST</span><span class="p">,</span> <span class="n">KEEP_LAST</span><span class="p">,</span> <span class="n">KEEP_NONE</span><span class="p">]</span><span class="o">=</span><span class="n">KEEP_FIRST</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">),</span> <span class="s2">&quot;DedupeRule: columns must be strings&quot;</span>
        <span class="k">assert</span> <span class="n">keep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ALL_KEEPS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;DedupeRule: keep must be one of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ALL_KEEPS</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span>

    <span class="k">def</span> <span class="nf">do_dedupe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing column(s) to dedupe on: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_dedupe</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">


















  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.basic.ExplodeValuesRule" class="doc doc-heading">
        <code>
ExplodeValuesRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>, <span title="etlrules.rule.ColumnsInOutMixin">ColumnsInOutMixin</span>)
        </code>



<a href="#etlrules.backends.common.basic.ExplodeValuesRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Explode a list of values into multiple rows with each value on a separate row</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code>Given df:
| A         |
|-----------|
| [1, 2, 3] |
| [4, 5]    |
| [6]       |
</code></pre></div></td></tr></table></div>
<blockquote>
<p>ExplodeValuesRule("A").apply(df)</p>
</blockquote>
<p>Result::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   |
|-----|
| 1   |
| 2   |
| 3   |
| 4   |
| 5   |
| 6   |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A column with values to round as per the specified scale.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_type</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional string with the type of the resulting exploded column. When not specified, the
column_type is backend implementation specific.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input column doesn't exist in the input dataframe.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/basic.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ExplodeValuesRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">,</span> <span class="n">ColumnsInOutMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Explode a list of values into multiple rows with each value on a separate row</span>

<span class="sd">    Example::</span>

<span class="sd">        Given df:</span>
<span class="sd">        | A         |</span>
<span class="sd">        |-----------|</span>
<span class="sd">        | [1, 2, 3] |</span>
<span class="sd">        | [4, 5]    |</span>
<span class="sd">        | [6]       |</span>

<span class="sd">    &gt; ExplodeValuesRule(&quot;A&quot;).apply(df)</span>

<span class="sd">    Result::</span>

<span class="sd">        | A   |</span>
<span class="sd">        |-----|</span>
<span class="sd">        | 1   |</span>
<span class="sd">        | 2   |</span>
<span class="sd">        | 3   |</span>
<span class="sd">        | 4   |</span>
<span class="sd">        | 5   |</span>
<span class="sd">        | 6   |</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column: A column with values to round as per the specified scale.</span>
<span class="sd">        column_type: An optional string with the type of the resulting exploded column. When not specified, the</span>
<span class="sd">            column_type is backend implementation specific.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">column_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_column</span> <span class="o">=</span> <span class="n">input_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="n">column_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_TYPES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">column_type</span><span class="si">}</span><span class="s2">&#39; is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_input_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_column</span><span class="si">}</span><span class="s2">&#39; is not present in the input dataframe.&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.basic.ProjectRule" class="doc doc-heading">
        <code>
ProjectRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.basic.ProjectRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Reshapes the data frame to keep, eliminate or re-order the set of columns.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>columns</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>The list of columns to keep or eliminate from the data frame.
The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>exclude</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False
In strict mode, if any column specified in the columns arg doesn't exist in the input data frame, a MissingColumnError exception is raised.
In non strict mode, the missing columns are ignored.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised in strict mode only, if any columns are missing from the input data frame.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/basic.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ProjectRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Reshapes the data frame to keep, eliminate or re-order the set of columns.</span>

<span class="sd">    Args:</span>
<span class="sd">        columns (Iterable[str]): The list of columns to keep or eliminate from the data frame.</span>
<span class="sd">            The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns.</span>
<span class="sd">        exclude (bool): When set to True, the columns in the columns arg will be excluded from the data frame. Boolean. Default: False</span>
<span class="sd">            In strict mode, if any column specified in the columns arg doesn&#39;t exist in the input data frame, a MissingColumnError exception is raised.</span>
<span class="sd">            In non strict mode, the missing columns are ignored.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised in strict mode only, if any columns are missing from the input data frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">),</span> <span class="s2">&quot;ProjectRule: columns must be strings&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude</span> <span class="o">=</span> <span class="n">exclude</span>

    <span class="k">def</span> <span class="nf">_get_remaining_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_column_names</span><span class="p">):</span>
        <span class="n">columns_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">df_column_names_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_column_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">columns_set</span> <span class="o">&lt;=</span> <span class="n">df_column_names_set</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No such columns: </span><span class="si">{</span><span class="n">columns_set</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">df_column_names_set</span><span class="si">}</span><span class="s2">. Available columns: </span><span class="si">{</span><span class="n">df_column_names_set</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude</span><span class="p">:</span>
            <span class="n">remaining_columns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df_column_names</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">columns_set</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remaining_columns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df_column_names_set</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">remaining_columns</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">remaining_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_remaining_columns</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">remaining_columns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.basic.RenameRule" class="doc doc-heading">
        <code>
RenameRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.basic.RenameRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Renames a set of columns in the data frame.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>mapper</code></td>
        <td><code>Mapping[str, str]</code></td>
        <td><p>A dictionary of old names (keys) and new names (values) to be used for the rename operation
The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised in strict mode only, if any columns (keys) are missing from the input data frame.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/basic.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">RenameRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Renames a set of columns in the data frame.</span>

<span class="sd">    Args:</span>
<span class="sd">        mapper: A dictionary of old names (keys) and new names (values) to be used for the rename operation</span>
<span class="sd">            The order of column names will be reflected in the result data frame, so this rule can be used to re-order columns.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised in strict mode only, if any columns (keys) are missing from the input data frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;mapper needs to be a dict {old_name:new_name}&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="s2">&quot;mapper needs to be a dict {old_name:new_name} where the names are str&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="n">mapper</span>

    <span class="k">def</span> <span class="nf">do_rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span>
        <span class="n">df_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="n">df_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing columns to rename: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">df_columns</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df_columns</span><span class="p">}</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rename</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">mapper</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.basic.ReplaceRule" class="doc doc-heading">
        <code>
ReplaceRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.basic.ReplaceRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Replaces some some values (or regular expressions) with another set of values (or regular expressions).</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># replaces A with new_A and b with new_b in col_A
rule = ReplaceRule(&quot;col_A&quot;, values=[&quot;A&quot;, &quot;b&quot;], new_values=[&quot;new_A&quot;, &quot;new_b&quot;])
rule.apply(data)

# replaces 1 with 3 and 2 with 4 in the col_I column
rule = ReplaceRule(&quot;col_I&quot;, values=[1, 2], new_values=[3, 4])
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A column with the input values.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>values</code></td>
        <td><code>Iterable[Union[int, float, str]]</code></td>
        <td><p>A sequence of values to replace. Regular expressions can be used to match values more widely,
in which case, the regex parameter must be set to True.
Values can be any supported types but they should match the type of the columns.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>new_values</code></td>
        <td><code>Iterable[Union[int, float, str]]</code></td>
        <td><p>A sequence of the same length as values. Each value within new_values will replace the
corresponding value in values (at the same index).
New values can be any supported types but they should match the type of the columns.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>regex</code></td>
        <td></td>
        <td><p>True if all the values and new_values are to be interpreted as regular expressions. Default: False.
regex=True is only applicable to string columns.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional column to hold the result with the new values.
Optional. If provided, if must have the same length as the columns sequence.
The existing columns are unchanged, and new columns are created with the upper case values.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, overwriting existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/basic.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ReplaceRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Replaces some some values (or regular expressions) with another set of values (or regular expressions).</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # replaces A with new_A and b with new_b in col_A</span>
<span class="sd">        rule = ReplaceRule(&quot;col_A&quot;, values=[&quot;A&quot;, &quot;b&quot;], new_values=[&quot;new_A&quot;, &quot;new_b&quot;])</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # replaces 1 with 3 and 2 with 4 in the col_I column</span>
<span class="sd">        rule = ReplaceRule(&quot;col_I&quot;, values=[1, 2], new_values=[3, 4])</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A column with the input values.</span>
<span class="sd">        values: A sequence of values to replace. Regular expressions can be used to match values more widely,</span>
<span class="sd">            in which case, the regex parameter must be set to True.</span>
<span class="sd">            Values can be any supported types but they should match the type of the columns.</span>
<span class="sd">        new_values: A sequence of the same length as values. Each value within new_values will replace the</span>
<span class="sd">            corresponding value in values (at the same index).</span>
<span class="sd">            New values can be any supported types but they should match the type of the columns.</span>
<span class="sd">        regex: True if all the values and new_values are to be interpreted as regular expressions. Default: False.</span>
<span class="sd">            regex=True is only applicable to string columns.</span>
<span class="sd">        output_column (Optional[str]): An optional column to hold the result with the new values.</span>
<span class="sd">            Optional. If provided, if must have the same length as the columns sequence.</span>
<span class="sd">            The existing columns are unchanged, and new columns are created with the upper case values.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, overwriting existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">str</span><span class="p">]],</span> <span class="n">new_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">str</span><span class="p">]],</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">new_values</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">new_values</span><span class="p">),</span> <span class="s2">&quot;values and new_values must be of the same length.&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;values must not be empty.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex</span> <span class="o">=</span> <span class="n">regex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regex</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.basic.RulesBlock" class="doc doc-heading">
        <code>
RulesBlock            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.basic.RulesBlock" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Groups rules into encapsulated blocks or units of rules that achieve one thing.
Blocks are reusable and encapsulated to reduce complexity.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>rules</code></td>
        <td><code>Iterable[etlrules.rule.BaseRule]</code></td>
        <td><p>An iterable of rules which are part of this block.
The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule).
The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block).
Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/basic.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">RulesBlock</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Groups rules into encapsulated blocks or units of rules that achieve one thing.</span>
<span class="sd">    Blocks are reusable and encapsulated to reduce complexity.</span>

<span class="sd">    Args:</span>
<span class="sd">        rules: An iterable of rules which are part of this block.</span>
<span class="sd">            The first rule in the block will take its input from the named_input of the RulesBlock (if any, if not from the main output of the previous rule).</span>
<span class="sd">            The last rule in the block will publish the output as the named_output of the RulesBlock (if any, or the main output of the block).</span>
<span class="sd">            Any named outputs in the block are not exposed to the rules outside of the block (proper encapsulation).</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rules</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">BaseRule</span><span class="p">],</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">rule</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">,</span> <span class="s2">&quot;RulesBlock: Empty rules set provided.&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">BaseRule</span><span class="p">)</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">),</span> <span class="p">[</span><span class="n">rule</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">BaseRule</span><span class="p">)]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">named_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;First rule in a RulesBlock must consume the main input/output&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">named_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Last rule in a RulesBlock must produce the main output&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data2</span> <span class="o">=</span> <span class="n">RuleData</span><span class="p">(</span>
            <span class="n">main_input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
            <span class="n">named_inputs</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">get_named_outputs</span><span class="p">()},</span>
            <span class="n">strict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strict</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">:</span>
            <span class="n">rule</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data2</span><span class="o">.</span><span class="n">get_main_output</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">dct</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">][</span><span class="s2">&quot;rules&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">rule</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dct</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">backend</span><span class="p">):</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;RulesBlock&quot;</span><span class="p">]</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">BaseRule</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rules&quot;</span><span class="p">,</span> <span class="p">())]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;rules&quot;</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">rules</span><span class="o">=</span><span class="n">rules</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">















  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.basic.SortRule" class="doc doc-heading">
        <code>
SortRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.basic.SortRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Sort the input dataframe by the given columns, either ascending or descending.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sort_by</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>Either a single column speified as a string or a list or tuple of columns to sort by</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ascending</code></td>
        <td><code>Union[bool, Iterable[bool]]</code></td>
        <td><p>Whether to sort ascending or descending. Boolean. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised when a column in the sort_by doesn't exist in the input dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>When multiple columns are specified, the first column decides the sort order.
For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/basic.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">SortRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Sort the input dataframe by the given columns, either ascending or descending.</span>

<span class="sd">    Args:</span>
<span class="sd">        sort_by: Either a single column speified as a string or a list or tuple of columns to sort by</span>
<span class="sd">        ascending: Whether to sort ascending or descending. Boolean. Default: True</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised when a column in the sort_by doesn&#39;t exist in the input dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        When multiple columns are specified, the first column decides the sort order.</span>
<span class="sd">        For any rows that have the same value in the first column, the second column is used to decide the sort order within that group and so on.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_by</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">ascending</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_by</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_by</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_by</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sort_by</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ascending</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sort_by</span><span class="p">)),</span> <span class="s2">&quot;ascending must be a bool or a list of bool of the same len as sort_by&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ascending</span> <span class="o">=</span> <span class="n">ascending</span>

    <span class="k">def</span> <span class="nf">do_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sort_by</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column(s) </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sort_by</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2"> are missing from the input dataframe.&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_sort</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.concat" class="doc doc-heading">
        <code>concat</code>



<a href="#etlrules.backends.common.concat" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.concat.HConcatRule" class="doc doc-heading">
        <code>
HConcatRule            (<a title="etlrules.rule.BinaryOpBaseRule" href="#etlrules.rule.BinaryOpBaseRule">BinaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.concat.HConcatRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Horizontally concatenates two dataframe with the result having the columns from the left dataframe followed by the columns from the right dataframe.</p>
<p>The columns from the left dataframe will be followed by the columns from the right dataframe in the result dataframe.
The two dataframes must not have columns with the same name.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code>Left dataframe:
| A   | B  |
| a   | 1  |
| b   | 2  |
| c   | 3  |

Right dataframe:
| C   | D  |
| d   | 4  |
| e   | 5  |
| f   | 6  |
</code></pre></div></td></tr></table></div>
<p>After a concat(left, right), the result will look like::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  | C   | D  |
| a   | 1  | d   | 4  |
| b   | 2  | e   | 5  |
| c   | 3  | f   | 6  |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>named_input_left</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the left side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input_right</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the right side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised if the two dataframes have columns with the same name.</p></td>
      </tr>
      <tr>
        <td><code>SchemaError</code></td>
        <td><p>raised in strict mode only if the two dataframes have different number of rows.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/concat.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">HConcatRule</span><span class="p">(</span><span class="n">BinaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Horizontally concatenates two dataframe with the result having the columns from the left dataframe followed by the columns from the right dataframe.</span>

<span class="sd">    The columns from the left dataframe will be followed by the columns from the right dataframe in the result dataframe.</span>
<span class="sd">    The two dataframes must not have columns with the same name.</span>

<span class="sd">    Example::</span>

<span class="sd">        Left dataframe:</span>
<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | 1  |</span>
<span class="sd">        | b   | 2  |</span>
<span class="sd">        | c   | 3  |</span>

<span class="sd">        Right dataframe:</span>
<span class="sd">        | C   | D  |</span>
<span class="sd">        | d   | 4  |</span>
<span class="sd">        | e   | 5  |</span>
<span class="sd">        | f   | 6  |  </span>

<span class="sd">    After a concat(left, right), the result will look like::</span>

<span class="sd">        | A   | B  | C   | D  |</span>
<span class="sd">        | a   | 1  | d   | 4  |</span>
<span class="sd">        | b   | 2  | e   | 5  |</span>
<span class="sd">        | c   | 3  | f   | 6  |</span>

<span class="sd">    Args:</span>
<span class="sd">        named_input_left: Which dataframe to use as the input on the left side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_input_right: Which dataframe to use as the input on the right side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>

<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ColumnAlreadyExistsError: raised if the two dataframes have columns with the same name.</span>
<span class="sd">        SchemaError: raised in strict mode only if the two dataframes have different number of rows.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_input_left</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">named_input_right</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># This __init__ not really needed but the type annotations are extracted from it</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input_left</span><span class="o">=</span><span class="n">named_input_left</span><span class="p">,</span> <span class="n">named_input_right</span><span class="o">=</span><span class="n">named_input_right</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_df</span><span class="p">,</span> <span class="n">right_df</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">left_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df_left</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">right_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df_right</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">overlapping_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlapping_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ColumnAlreadyExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column(s) </span><span class="si">{</span><span class="n">overlapping_names</span><span class="si">}</span><span class="s2"> exist in both dataframes.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_df</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_df</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SchemaError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HConcat needs the two dataframe to have the same number of rows. left df=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">left_df</span><span class="p">)</span><span class="si">}</span><span class="s2"> rows, right df=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">right_df</span><span class="p">)</span><span class="si">}</span><span class="s2"> rows.&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_concat</span><span class="p">(</span><span class="n">left_df</span><span class="p">,</span> <span class="n">right_df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.concat.VConcatRule" class="doc doc-heading">
        <code>
VConcatRule            (<a title="etlrules.rule.BinaryOpBaseRule" href="#etlrules.rule.BinaryOpBaseRule">BinaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.concat.VConcatRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Vertically concatenates two dataframe with the result having the rows from the left dataframe followed by the rows from the right dataframe.</p>
<p>The rows of the right dataframe are added at the bottom of the rows from the left dataframe in the result dataframe.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code>Left dataframe:
| A   | B  |
| a   | 1  |
| b   | 2  |
| c   | 3  |

Right dataframe:
| A   | B  |
| d   | 4  |
| e   | 5  |
| f   | 6  |
</code></pre></div></td></tr></table></div>
<p>After a concat(left, right), the result will look like::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| a   | 1  |
| b   | 2  |
| c   | 3  |
| d   | 4  |
| e   | 5  |
| f   | 6  |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>named_input_left</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the left side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input_right</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the right side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>subset_columns</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>A subset list of columns available in both dataframes.
Only these columns will be concated.
The effect is similar to doing a ProjectRule(subset_columns) on both dataframes before the concat.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if any subset columns specified are missing from any of the dataframe.</p></td>
      </tr>
      <tr>
        <td><code>SchemaError</code></td>
        <td><p>raised in strict mode only if the columns differ between the two dataframes and subset_columns is not specified.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In strict mode, as described above, SchemaError is raised if the columns are not the same (names, types can be inferred).
In non-strict mode, columns are not checked and values are filled with NA when missing.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/concat.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">VConcatRule</span><span class="p">(</span><span class="n">BinaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Vertically concatenates two dataframe with the result having the rows from the left dataframe followed by the rows from the right dataframe.</span>

<span class="sd">    The rows of the right dataframe are added at the bottom of the rows from the left dataframe in the result dataframe.</span>

<span class="sd">    Example::</span>

<span class="sd">        Left dataframe:</span>
<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | 1  |</span>
<span class="sd">        | b   | 2  |</span>
<span class="sd">        | c   | 3  |</span>

<span class="sd">        Right dataframe:</span>
<span class="sd">        | A   | B  |</span>
<span class="sd">        | d   | 4  |</span>
<span class="sd">        | e   | 5  |</span>
<span class="sd">        | f   | 6  |  </span>

<span class="sd">    After a concat(left, right), the result will look like::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | 1  |</span>
<span class="sd">        | b   | 2  |</span>
<span class="sd">        | c   | 3  |</span>
<span class="sd">        | d   | 4  |</span>
<span class="sd">        | e   | 5  |</span>
<span class="sd">        | f   | 6  |</span>

<span class="sd">    Args:</span>
<span class="sd">        named_input_left: Which dataframe to use as the input on the left side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_input_right: Which dataframe to use as the input on the right side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        subset_columns: A subset list of columns available in both dataframes.</span>
<span class="sd">            Only these columns will be concated.</span>
<span class="sd">            The effect is similar to doing a ProjectRule(subset_columns) on both dataframes before the concat.</span>

<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if any subset columns specified are missing from any of the dataframe.</span>
<span class="sd">        SchemaError: raised in strict mode only if the columns differ between the two dataframes and subset_columns is not specified.</span>

<span class="sd">    Note:</span>
<span class="sd">        In strict mode, as described above, SchemaError is raised if the columns are not the same (names, types can be inferred).</span>
<span class="sd">        In non-strict mode, columns are not checked and values are filled with NA when missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_input_left</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">named_input_right</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">subset_columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input_left</span><span class="o">=</span><span class="n">named_input_left</span><span class="p">,</span> <span class="n">named_input_right</span><span class="o">=</span><span class="n">named_input_right</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">subset_columns</span><span class="p">]</span> <span class="k">if</span> <span class="n">subset_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">do_concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_df</span><span class="p">,</span> <span class="n">right_df</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">left_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df_left</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">right_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df_right</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing columns in the left dataframe of the concat operation: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing columns in the right dataframe of the concat operation: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">left_df</span> <span class="o">=</span> <span class="n">left_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span><span class="p">]</span>
            <span class="n">right_df</span> <span class="o">=</span> <span class="n">right_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subset_columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SchemaError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;VConcat needs both dataframe have the same schema. Missing columns in the right df: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">. Missing columns in the left df: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">left_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="n">right_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_concat</span><span class="p">(</span><span class="n">left_df</span><span class="p">,</span> <span class="n">right_df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.conditions" class="doc doc-heading">
        <code>conditions</code>



<a href="#etlrules.backends.common.conditions" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.conditions.FilterRule" class="doc doc-heading">
        <code>
FilterRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.conditions.FilterRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Exclude rows based on a condition.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code>Given df:
| A   | B  |
| 1   | 2  |
| 5   | 3  |
| 3   | 4  |

rule = FilterRule(&quot;df[&#39;A&#39;] &gt; df[&#39;B&#39;]&quot;)
rule.apply(df)
</code></pre></div></td></tr></table></div>
<p>Result::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| 5   | 3  |
</code></pre></div></td></tr></table></div>
<p>Same example using discarded_matching_rows=True::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = FilterRule(&quot;df[&#39;A&#39;] &gt; df[&#39;B&#39;]&quot;, discard_matching_rows=True)
rule.apply(df)
</code></pre></div></td></tr></table></div>
<p>Result::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| 1   | 2  |
| 3   | 4  |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>condition_expression</code></td>
        <td><code>str</code></td>
        <td><p>An expression as a string. The expression must evaluate to a boolean scalar or a boolean series.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>discard_matching_rows</code></td>
        <td><code>bool</code></td>
        <td><p>By default the rows matching the condition (ie where the condition is True) are kept, the rest of the
rows being dropped from the result. Setting this parameter to True essentially inverts the condition, so the rows
matching the condition are discarded and the rest of the rows kept. Default: False.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>named_output_discarded</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>A named output for the records being discarded if those need to be kept for further processing.
Default: None, which doesn't keep track of discarded records.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ExpressionSyntaxError</code></td>
        <td><p>raised if the column expression has a Python syntax error.</p></td>
      </tr>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>raised if an operation is not supported between the types involved</p></td>
      </tr>
      <tr>
        <td><code>NameError</code></td>
        <td><p>raised if an unknown variable is used</p></td>
      </tr>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>raised if you try to use an unknown column (i.e. df['ANY_UNKNOWN_COLUMN'])</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/conditions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">FilterRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Exclude rows based on a condition.</span>

<span class="sd">    Example::</span>

<span class="sd">        Given df:</span>
<span class="sd">        | A   | B  |</span>
<span class="sd">        | 1   | 2  |</span>
<span class="sd">        | 5   | 3  |</span>
<span class="sd">        | 3   | 4  |</span>

<span class="sd">        rule = FilterRule(&quot;df[&#39;A&#39;] &gt; df[&#39;B&#39;]&quot;)</span>
<span class="sd">        rule.apply(df)</span>

<span class="sd">    Result::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | 5   | 3  |</span>

<span class="sd">    Same example using discarded_matching_rows=True::</span>

<span class="sd">        rule = FilterRule(&quot;df[&#39;A&#39;] &gt; df[&#39;B&#39;]&quot;, discard_matching_rows=True)</span>
<span class="sd">        rule.apply(df)</span>

<span class="sd">    Result::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | 1   | 2  |</span>
<span class="sd">        | 3   | 4  |</span>

<span class="sd">    Args:</span>
<span class="sd">        condition_expression: An expression as a string. The expression must evaluate to a boolean scalar or a boolean series.</span>
<span class="sd">        discard_matching_rows: By default the rows matching the condition (ie where the condition is True) are kept, the rest of the</span>
<span class="sd">            rows being dropped from the result. Setting this parameter to True essentially inverts the condition, so the rows</span>
<span class="sd">            matching the condition are discarded and the rest of the rows kept. Default: False.</span>
<span class="sd">        named_output_discarded: A named output for the records being discarded if those need to be kept for further processing.</span>
<span class="sd">            Default: None, which doesn&#39;t keep track of discarded records.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ExpressionSyntaxError: raised if the column expression has a Python syntax error.</span>
<span class="sd">        TypeError: raised if an operation is not supported between the types involved</span>
<span class="sd">        NameError: raised if an unknown variable is used</span>
<span class="sd">        KeyError: raised if you try to use an unknown column (i.e. df[&#39;ANY_UNKNOWN_COLUMN&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EXCLUDE_FROM_COMPARE</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_condition_expression&#39;</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition_expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">discard_matching_rows</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">named_output_discarded</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">condition_expression</span><span class="p">,</span> <span class="s2">&quot;condition_expression cannot be empty&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition_expression</span> <span class="o">=</span> <span class="n">condition_expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_matching_rows</span> <span class="o">=</span> <span class="n">discard_matching_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_output_discarded</span> <span class="o">=</span> <span class="n">named_output_discarded</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_condition_expression</span><span class="p">()</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.conditions.IfThenElseRule" class="doc doc-heading">
        <code>
IfThenElseRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.conditions.IfThenElseRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Calculates the ouput based on a condition (If Cond is true Then use then_value Else use else_value).</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code>Given df:
| A   | B  |
| 1   | 2  |
| 5   | 3  |
| 3   | 4  |

rule = IfThenElseRule(&quot;df[&#39;A&#39;] &gt; df[&#39;B&#39;]&quot;, output_column=&quot;C&quot;, then_value=&quot;A is greater&quot;, else_value=&quot;B is greater&quot;)
rule.apply(df)
</code></pre></div></td></tr></table></div>
<p>Result::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  | C            |
| 1   | 2  | B is greater |
| 5   | 3  | A is greater |
| 3   | 4  | B is greater |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>condition_expression</code></td>
        <td><code>str</code></td>
        <td><p>An expression as a string. The expression must evaluate to a boolean scalar or a boolean series.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>then_value</code></td>
        <td><code>Union[int, float, bool, str]</code></td>
        <td><p>The value to use if the condition is true.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>then_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Use the value from the then_column if the condition is true.
One and only one of then_value and then_column can be used.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>else_value</code></td>
        <td><code>Union[int, float, bool, str]</code></td>
        <td><p>The value to use if the condition is false.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>else_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Use the value from the else_column if the condition is false.
One and only one of the else_value and else_column can be used.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>str</code></td>
        <td><p>The column name of the result column which will be added to the dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if a column with the same name already exists in the dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ExpressionSyntaxError</code></td>
        <td><p>raised if the column expression has a Python syntax error.</p></td>
      </tr>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised when then_column or else_column are used but they are missing from the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>raised if an operation is not supported between the types involved</p></td>
      </tr>
      <tr>
        <td><code>NameError</code></td>
        <td><p>raised if an unknown variable is used</p></td>
      </tr>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>raised if you try to use an unknown column (i.e. df['ANY_UNKNOWN_COLUMN'])</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/conditions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">IfThenElseRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculates the ouput based on a condition (If Cond is true Then use then_value Else use else_value).</span>

<span class="sd">    Example::</span>

<span class="sd">        Given df:</span>
<span class="sd">        | A   | B  |</span>
<span class="sd">        | 1   | 2  |</span>
<span class="sd">        | 5   | 3  |</span>
<span class="sd">        | 3   | 4  |</span>

<span class="sd">        rule = IfThenElseRule(&quot;df[&#39;A&#39;] &gt; df[&#39;B&#39;]&quot;, output_column=&quot;C&quot;, then_value=&quot;A is greater&quot;, else_value=&quot;B is greater&quot;)</span>
<span class="sd">        rule.apply(df)</span>

<span class="sd">    Result::</span>

<span class="sd">        | A   | B  | C            |</span>
<span class="sd">        | 1   | 2  | B is greater |</span>
<span class="sd">        | 5   | 3  | A is greater |</span>
<span class="sd">        | 3   | 4  | B is greater |</span>

<span class="sd">    Args:</span>
<span class="sd">        condition_expression: An expression as a string. The expression must evaluate to a boolean scalar or a boolean series.</span>
<span class="sd">        then_value: The value to use if the condition is true.</span>
<span class="sd">        then_column: Use the value from the then_column if the condition is true.</span>
<span class="sd">            One and only one of then_value and then_column can be used.</span>
<span class="sd">        else_value: The value to use if the condition is false.</span>
<span class="sd">        else_column: Use the value from the else_column if the condition is false.</span>
<span class="sd">            One and only one of the else_value and else_column can be used.</span>
<span class="sd">        output_column: The column name of the result column which will be added to the dataframe.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if a column with the same name already exists in the dataframe.</span>
<span class="sd">        ExpressionSyntaxError: raised if the column expression has a Python syntax error.</span>
<span class="sd">        MissingColumnError: raised when then_column or else_column are used but they are missing from the input dataframe.</span>
<span class="sd">        TypeError: raised if an operation is not supported between the types involved</span>
<span class="sd">        NameError: raised if an unknown variable is used</span>
<span class="sd">        KeyError: raised if you try to use an unknown column (i.e. df[&#39;ANY_UNKNOWN_COLUMN&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EXCLUDE_FROM_COMPARE</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_condition_expression&#39;</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition_expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">then_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">bool</span><span class="p">,</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">then_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">else_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">bool</span><span class="p">,</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">else_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">bool</span><span class="p">(</span><span class="n">then_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">then_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;One and only one of then_value and then_column can be specified.&quot;</span>
        <span class="k">assert</span> <span class="nb">bool</span><span class="p">(</span><span class="n">else_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">else_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;One and only one of else_value and else_column can be specified.&quot;</span>
        <span class="k">assert</span> <span class="n">condition_expression</span><span class="p">,</span> <span class="s2">&quot;condition_expression cannot be empty&quot;</span>
        <span class="k">assert</span> <span class="n">output_column</span><span class="p">,</span> <span class="s2">&quot;output_column cannot be empty&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition_expression</span> <span class="o">=</span> <span class="n">condition_expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="o">=</span> <span class="n">output_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">then_value</span> <span class="o">=</span> <span class="n">then_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">then_column</span> <span class="o">=</span> <span class="n">then_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">else_value</span> <span class="o">=</span> <span class="n">else_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">else_column</span> <span class="o">=</span> <span class="n">else_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_condition_expression</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_validate_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_columns</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="ow">in</span> <span class="n">df_columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ColumnAlreadyExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_column</span><span class="si">}</span><span class="s2"> already exists in the input dataframe.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">then_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">then_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df_columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">then_column</span><span class="si">}</span><span class="s2"> is missing from the input dataframe.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df_columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">else_column</span><span class="si">}</span><span class="s2"> is missing from the input dataframe.&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.datetime" class="doc doc-heading">
        <code>datetime</code>



<a href="#etlrules.backends.common.datetime" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeAddRule" class="doc doc-heading">
        <code>
DateTimeAddRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeAddRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Adds a number of units (days, hours, minutes, etc.) to a datetime column.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># adds 2 days the A column
rule = DateTimeAddRule(&quot;A&quot;, 2, &quot;days&quot;)
rule.apply(data)

# adds 2 hours to the A column
rule = DateTimeAddRule(&quot;A&quot;, 2, &quot;hours&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The name of a datetime column to add to.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit_value</code></td>
        <td><code>Union[int,float,str]</code></td>
        <td><p>The number of units to add to the datetime column.
The unit_value can be negative, in which case this rule performs a substract.</p>
<p>A name of an existing column can be passed into unit_value, in which case, that
column will be added to the input_column.
If the column is a timedelta, it will be added as is, if it's a numeric column,
then it will be interpreted based on the unit parameter (e.g. years/days/hours/etc.).
In this case, if the column specified in the unit_value doesn't exist,
MissingColumnError is raised.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit</code></td>
        <td><code>str</code></td>
        <td><p>Specifies what unit the unit_value is in. Supported values are:
years, months, weeks, weekdays, days, hours, minutes, seconds, microseconds, nanoseconds.
weekdays skips weekends (ie Saturdays and Sundays).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The name of a new column with the result. Optional.
If not provided, the result is updated in place.
In strict mode, if provided, the output_column must not exist in the input dataframe.
In non-strict mode, if provided, the output_column with overwrite a column with
the same name in the input dataframe (if any).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if unit_value is a name of a column but it doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raised if unit_value is a column which is not a timedelta column and the unit parameter is not specified.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, missing columns or overwriting existing columns are ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeAddRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Adds a number of units (days, hours, minutes, etc.) to a datetime column.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # adds 2 days the A column</span>
<span class="sd">        rule = DateTimeAddRule(&quot;A&quot;, 2, &quot;days&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # adds 2 hours to the A column</span>
<span class="sd">        rule = DateTimeAddRule(&quot;A&quot;, 2, &quot;hours&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The name of a datetime column to add to.</span>
<span class="sd">        unit_value (Union[int,float,str]): The number of units to add to the datetime column.</span>
<span class="sd">            The unit_value can be negative, in which case this rule performs a substract.</span>

<span class="sd">            A name of an existing column can be passed into unit_value, in which case, that</span>
<span class="sd">            column will be added to the input_column.</span>
<span class="sd">            If the column is a timedelta, it will be added as is, if it&#39;s a numeric column,</span>
<span class="sd">            then it will be interpreted based on the unit parameter (e.g. years/days/hours/etc.).</span>
<span class="sd">            In this case, if the column specified in the unit_value doesn&#39;t exist,</span>
<span class="sd">            MissingColumnError is raised.</span>

<span class="sd">        unit (str): Specifies what unit the unit_value is in. Supported values are:</span>
<span class="sd">            years, months, weeks, weekdays, days, hours, minutes, seconds, microseconds, nanoseconds.</span>
<span class="sd">            weekdays skips weekends (ie Saturdays and Sundays).</span>

<span class="sd">        output_column (Optional[str]): The name of a new column with the result. Optional.</span>
<span class="sd">            If not provided, the result is updated in place.</span>
<span class="sd">            In strict mode, if provided, the output_column must not exist in the input dataframe.</span>
<span class="sd">            In non-strict mode, if provided, the output_column with overwrite a column with</span>
<span class="sd">            the same name in the input dataframe (if any).</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        MissingColumnError: raised if unit_value is a name of a column but it doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>
<span class="sd">        ValueError: raised if unit_value is a column which is not a timedelta column and the unit parameter is not specified.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, missing columns or overwriting existing columns are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> 
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;years&quot;</span><span class="p">,</span> <span class="s2">&quot;months&quot;</span><span class="p">,</span> <span class="s2">&quot;weeks&quot;</span><span class="p">,</span> <span class="s2">&quot;weekdays&quot;</span><span class="p">,</span> <span class="s2">&quot;days&quot;</span><span class="p">,</span> <span class="s2">&quot;hours&quot;</span><span class="p">,</span> <span class="s2">&quot;minutes&quot;</span><span class="p">,</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span> <span class="s2">&quot;milliseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;microseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;nanoseconds&quot;</span><span class="p">]],</span>
                 <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_value</span> <span class="o">=</span> <span class="n">unit_value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">DT_ARITHMETIC_UNITS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unsupported unit: &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;. It must be one of </span><span class="si">{</span><span class="n">DT_ARITHMETIC_UNITS</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeDiffRule" class="doc doc-heading">
        <code>
DateTimeDiffRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeDiffRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Calculates the difference between two datetime columns, optionally extracting it in the specified unit.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code># calculates the A - B in days
rule = DateTimeDiffRule(&quot;A&quot;, &quot;B&quot;, unit=&quot;days&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The name of a datetime column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>input_column2</code></td>
        <td><code>str</code></td>
        <td><p>The name of the second datetime column.
The result will be input_column - input_column2</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>If specified, it will extract the given component of the difference:
years, months, days, hours, minutes, seconds, microseconds, nanoseconds.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The name of a new column with the result. Optional.
If not provided, the result is updated in place.
In strict mode, if provided, the output_column must not exist in the input dataframe.
In non-strict mode, if provided, the output_column with overwrite a column with
the same name in the input dataframe (if any).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if either input_column or input_column2 don't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>For best results, round the datetime columns using one of the rounding rules before
calculating the difference. Otherwise, this rule will tend to truncate/round down.
For example: 2023-05-05 10:00:00 - 2023-05-04 10:00:01 will result in 0 days even though
the difference is 23:59:59. In cases like this one, it might be preferable to round, in this
case perhaps round to "day" using DateTimeRoundRule or DateTimeRoundDownRule. This will result
in a 2023-05-05 00:00:00 - 2023-05-04 00:00:00 which results in 1 day.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeDiffRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculates the difference between two datetime columns, optionally extracting it in the specified unit.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # calculates the A - B in days</span>
<span class="sd">        rule = DateTimeDiffRule(&quot;A&quot;, &quot;B&quot;, unit=&quot;days&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The name of a datetime column.</span>
<span class="sd">        input_column2 (str): The name of the second datetime column.</span>
<span class="sd">            The result will be input_column - input_column2</span>

<span class="sd">        unit (Optional[str]): If specified, it will extract the given component of the difference:</span>
<span class="sd">            years, months, days, hours, minutes, seconds, microseconds, nanoseconds.</span>

<span class="sd">        output_column (Optional[str]): The name of a new column with the result. Optional.</span>
<span class="sd">            If not provided, the result is updated in place.</span>
<span class="sd">            In strict mode, if provided, the output_column must not exist in the input dataframe.</span>
<span class="sd">            In non-strict mode, if provided, the output_column with overwrite a column with</span>
<span class="sd">            the same name in the input dataframe (if any).</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if either input_column or input_column2 don&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        For best results, round the datetime columns using one of the rounding rules before</span>
<span class="sd">        calculating the difference. Otherwise, this rule will tend to truncate/round down.</span>
<span class="sd">        For example: 2023-05-05 10:00:00 - 2023-05-04 10:00:01 will result in 0 days even though</span>
<span class="sd">        the difference is 23:59:59. In cases like this one, it might be preferable to round, in this</span>
<span class="sd">        case perhaps round to &quot;day&quot; using DateTimeRoundRule or DateTimeRoundDownRule. This will result</span>
<span class="sd">        in a 2023-05-05 00:00:00 - 2023-05-04 00:00:00 which results in 1 day.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SUPPORTED_COMPONENTS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;days&quot;</span><span class="p">,</span> <span class="s2">&quot;hours&quot;</span><span class="p">,</span> <span class="s2">&quot;minutes&quot;</span><span class="p">,</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="s2">&quot;microseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;nanoseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;total_seconds&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">SIGN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">EXCLUDE_FROM_SERIALIZE</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;unit_value&#39;</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">input_column2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;days&quot;</span><span class="p">,</span> <span class="s2">&quot;hours&quot;</span><span class="p">,</span> <span class="s2">&quot;minutes&quot;</span><span class="p">,</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span> <span class="s2">&quot;milliseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;microseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;nanoseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;total_seconds&quot;</span><span class="p">]],</span>
                 <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">input_column2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_column2</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;input_column2 must be a non-empty string representing the name of a column.&quot;</span>
        <span class="k">assert</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_COMPONENTS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;unit must be None of one of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_COMPONENTS</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span>
                         <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_column2</span> <span class="o">=</span> <span class="n">input_column2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">















  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeExtractComponentRule" class="doc doc-heading">
        <code>
DateTimeExtractComponentRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeExtractComponentRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Extract an individual component of a date/time (e.g. year, month, day, hour, etc.).</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code># extracts the year component from col_A. E.g. 2023-05-05 10:00:00 will extract 2023
rule = DateTimeExtractComponentRule(&quot;col_A&quot;, component=&quot;year&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A datetime column to extract the given component from.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>component</code></td>
        <td><code>str</code></td>
        <td><p>The component of the datatime to extract from the datetime.
When the component is one of (year, month, day, hour, minute, second, microsecond) then
the extracted component will be an integer with the respective component of the datetime.</p>
<p>When component is weekday, the component will be an integer with the values 0-6, with
Monday being 0 and Sunday 6.</p>
<p>When the component is weekday_name or month_name, the result column will be a string
column with the names of the weekdays (e.g. Monday, Tuesday, etc.) or month names
respectively (e.g. January, February, etc.). The names will be printed in the language
specified in the locale parameter (or English as the default).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>locale</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional locale string applicable to weekday_name and month_name. When specified,
the names will use the given locale to print the names in the given language.
Default: en_US.utf8 will print the names in English.
Use the command <code>locale -a</code> on your terminal on Unix systems to find your locale language code.
Trying to set the locale to a value that doesn't appear under the <code>locale -a</code> output will fail
with ValueError: Unsupported locale.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional column name to contain the result.
If provided, if must have the same length as the columns sequence.
The existing columns are unchanged, and new columns are created with the component extracted.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raised if a locale is specified which is not supported or available on the machine running the scripts.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, overwriting existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeExtractComponentRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Extract an individual component of a date/time (e.g. year, month, day, hour, etc.).</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # extracts the year component from col_A. E.g. 2023-05-05 10:00:00 will extract 2023</span>
<span class="sd">        rule = DateTimeExtractComponentRule(&quot;col_A&quot;, component=&quot;year&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A datetime column to extract the given component from.</span>
<span class="sd">        component: The component of the datatime to extract from the datetime.</span>
<span class="sd">            When the component is one of (year, month, day, hour, minute, second, microsecond) then</span>
<span class="sd">            the extracted component will be an integer with the respective component of the datetime.</span>

<span class="sd">            When component is weekday, the component will be an integer with the values 0-6, with</span>
<span class="sd">            Monday being 0 and Sunday 6.</span>

<span class="sd">            When the component is weekday_name or month_name, the result column will be a string</span>
<span class="sd">            column with the names of the weekdays (e.g. Monday, Tuesday, etc.) or month names</span>
<span class="sd">            respectively (e.g. January, February, etc.). The names will be printed in the language</span>
<span class="sd">            specified in the locale parameter (or English as the default).</span>

<span class="sd">        locale: An optional locale string applicable to weekday_name and month_name. When specified,</span>
<span class="sd">            the names will use the given locale to print the names in the given language.</span>
<span class="sd">            Default: en_US.utf8 will print the names in English.</span>
<span class="sd">            Use the command `locale -a` on your terminal on Unix systems to find your locale language code.</span>
<span class="sd">            Trying to set the locale to a value that doesn&#39;t appear under the `locale -a` output will fail</span>
<span class="sd">            with ValueError: Unsupported locale.</span>
<span class="sd">        output_column (Optional[str]): An optional column name to contain the result.</span>
<span class="sd">            If provided, if must have the same length as the columns sequence.</span>
<span class="sd">            The existing columns are unchanged, and new columns are created with the component extracted.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>
<span class="sd">        ValueError: raised if a locale is specified which is not supported or available on the machine running the scripts.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, overwriting existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SUPPORTED_COMPONENTS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;month&quot;</span><span class="p">,</span> <span class="s2">&quot;day&quot;</span><span class="p">,</span> <span class="s2">&quot;hour&quot;</span><span class="p">,</span> <span class="s2">&quot;minute&quot;</span><span class="p">,</span> <span class="s2">&quot;second&quot;</span><span class="p">,</span>
        <span class="s2">&quot;microsecond&quot;</span><span class="p">,</span> <span class="s2">&quot;nanosecond&quot;</span><span class="p">,</span>
        <span class="s2">&quot;weekday&quot;</span><span class="p">,</span> <span class="s2">&quot;day_name&quot;</span><span class="p">,</span> <span class="s2">&quot;month_name&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">component</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">locale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component</span> <span class="o">=</span> <span class="n">component</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_COMPONENTS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unsupported component=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="si">}</span><span class="s2">. Must be one of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_COMPONENTS</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locale</span> <span class="o">=</span> <span class="n">locale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locale</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locale</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cannot_set_locale</span><span class="p">(</span><span class="n">locale</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported locale: </span><span class="si">{</span><span class="n">locale</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_locale</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_cannot_set_locale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locale</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeLocalNowRule" class="doc doc-heading">
        <code>
DateTimeLocalNowRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeLocalNowRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Adds a new column with the local date/time.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = DateTimeLocalNowRule(output_column=&quot;LocalTimeNow&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>output_column</code></td>
        <td></td>
        <td><p>The name of the column to be added to the dataframe.
This column will be populated with the local date/time at the time of the call.
The same value will be populated for all rows.
The date/time populated is a "naive" datetime ie: doesn't have a timezone information.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the input dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, if the output_column exists in the input dataframe, it will be overwritten.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeLocalNowRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Adds a new column with the local date/time.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        rule = DateTimeLocalNowRule(output_column=&quot;LocalTimeNow&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        output_column: The name of the column to be added to the dataframe.</span>
<span class="sd">            This column will be populated with the local date/time at the time of the call.</span>
<span class="sd">            The same value will be populated for all rows.</span>
<span class="sd">            The date/time populated is a &quot;naive&quot; datetime ie: doesn&#39;t have a timezone information.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the input dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, if the output_column exists in the input dataframe, it will be overwritten.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">output_column</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_column</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="o">=</span> <span class="n">output_column</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeRoundDownRule" class="doc doc-heading">
        <code>
DateTimeRoundDownRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeRoundDownRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Rounds down (truncates) a set of datetime columns to the specified granularity (day, hour, minute, etc.).</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># rounds the A column to the nearest second
rule = DateTimeRoundDownRule(&quot;A&quot;, &quot;second&quot;)
rule.apply(data)

# rounds the A column to days
rule = DateTimeRoundDownRule(&quot;A&quot;, &quot;day&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The column name to round according to the unit specified.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit</code></td>
        <td><code>str</code></td>
        <td><p>Specifies the unit of rounding.
That is: rounding to the nearest day, hour, minute, etc.</p>
<p>The supported units are:
    day: removes the hours/minutes/etc.
    hour: removes the minutes/seconds etc.
    minute: removes the seconds/etc.
    second: removes the milliseconds/etc.
    millisecond: removes the microseconds
    microsecond: removes nanoseconds (if any)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The name of a new column with the result. Optional.
If not provided, the result is updated in place.
In strict mode, if provided, the output_column must not exist in the input dataframe.
In non-strict mode, if provided, the output_column with overwrite a column with
the same name in the input dataframe (if any).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, overwriting existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeRoundDownRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Rounds down (truncates) a set of datetime columns to the specified granularity (day, hour, minute, etc.).</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # rounds the A column to the nearest second</span>
<span class="sd">        rule = DateTimeRoundDownRule(&quot;A&quot;, &quot;second&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # rounds the A column to days</span>
<span class="sd">        rule = DateTimeRoundDownRule(&quot;A&quot;, &quot;day&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The column name to round according to the unit specified.</span>
<span class="sd">        unit (str): Specifies the unit of rounding.</span>
<span class="sd">            That is: rounding to the nearest day, hour, minute, etc.</span>

<span class="sd">            The supported units are:</span>
<span class="sd">                day: removes the hours/minutes/etc.</span>
<span class="sd">                hour: removes the minutes/seconds etc.</span>
<span class="sd">                minute: removes the seconds/etc.</span>
<span class="sd">                second: removes the milliseconds/etc.</span>
<span class="sd">                millisecond: removes the microseconds</span>
<span class="sd">                microsecond: removes nanoseconds (if any)</span>

<span class="sd">        output_column (Optional[str]): The name of a new column with the result. Optional.</span>
<span class="sd">            If not provided, the result is updated in place.</span>
<span class="sd">            In strict mode, if provided, the output_column must not exist in the input dataframe.</span>
<span class="sd">            In non-strict mode, if provided, the output_column with overwrite a column with</span>
<span class="sd">            the same name in the input dataframe (if any).</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, overwriting existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">ROUND_TRUNC_UNITS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;unit must be one of </span><span class="si">{</span><span class="n">ROUND_TRUNC_UNITS</span><span class="si">}</span><span class="s2"> and not &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeRoundRule" class="doc doc-heading">
        <code>
DateTimeRoundRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeRoundRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Rounds a set of datetime columns to the specified granularity (day, hour, minute, etc.).</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># rounds the A column to the nearest second
rule = DateTimeRoundRule(&quot;A&quot;, &quot;second&quot;)
rule.apply(data)

# rounds the A column to days
rule = DateTimeRoundRule(&quot;A&quot;, &quot;day&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The column name to round according to the unit specified.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit</code></td>
        <td><code>str</code></td>
        <td><p>Specifies the unit of rounding.
That is: rounding to the nearest day, hour, minute, etc.</p>
<p>The supported units are:
    day: anything up to 12:00:00 rounds down to the current day, after that up to the next day
    hour: anything up to 30th minute rounds down to the current hour, after that up to the next hour
    minute: anything up to 30th second rounds down to the current minute, after that up to the next minute
    second: rounds to the nearest second (if the column has milliseconds)
    millisecond: rounds to the nearest millisecond (if the column has microseconds)
    microsecond: rounds to the nearest microsecond
    nanosecond: rounds to the nearest nanosecond</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The name of a new column with the result. Optional.
If not provided, the result is updated in place.
In strict mode, if provided, the output_column must not exist in the input dataframe.
In non-strict mode, if provided, the output_column with overwrite a column with
the same name in the input dataframe (if any).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, overwriting existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeRoundRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Rounds a set of datetime columns to the specified granularity (day, hour, minute, etc.).</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # rounds the A column to the nearest second</span>
<span class="sd">        rule = DateTimeRoundRule(&quot;A&quot;, &quot;second&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # rounds the A column to days</span>
<span class="sd">        rule = DateTimeRoundRule(&quot;A&quot;, &quot;day&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The column name to round according to the unit specified.</span>
<span class="sd">        unit (str): Specifies the unit of rounding.</span>
<span class="sd">            That is: rounding to the nearest day, hour, minute, etc.</span>

<span class="sd">            The supported units are:</span>
<span class="sd">                day: anything up to 12:00:00 rounds down to the current day, after that up to the next day</span>
<span class="sd">                hour: anything up to 30th minute rounds down to the current hour, after that up to the next hour</span>
<span class="sd">                minute: anything up to 30th second rounds down to the current minute, after that up to the next minute</span>
<span class="sd">                second: rounds to the nearest second (if the column has milliseconds)</span>
<span class="sd">                millisecond: rounds to the nearest millisecond (if the column has microseconds)</span>
<span class="sd">                microsecond: rounds to the nearest microsecond</span>
<span class="sd">                nanosecond: rounds to the nearest nanosecond</span>

<span class="sd">        output_column (Optional[str]): The name of a new column with the result. Optional.</span>
<span class="sd">            If not provided, the result is updated in place.</span>
<span class="sd">            In strict mode, if provided, the output_column must not exist in the input dataframe.</span>
<span class="sd">            In non-strict mode, if provided, the output_column with overwrite a column with</span>
<span class="sd">            the same name in the input dataframe (if any).</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, overwriting existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">ROUND_TRUNC_UNITS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;unit must be one of </span><span class="si">{</span><span class="n">ROUND_TRUNC_UNITS</span><span class="si">}</span><span class="s2"> and not &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeRoundUpRule" class="doc doc-heading">
        <code>
DateTimeRoundUpRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeRoundUpRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Rounds up a set of datetime columns to the specified granularity (day, hour, minute, etc.).</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># rounds the A column to the nearest second
rule = DateTimeRoundUpRule(&quot;A&quot;, &quot;second&quot;)
rule.apply(data)

# rounds A column to days
rule = DateTimeRoundUpRule(&quot;A&quot;, &quot;day&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The column name to round according to the unit specified.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit</code></td>
        <td><code>str</code></td>
        <td><p>Specifies the unit of rounding.
That is: rounding to the nearest day, hour, minute, etc.</p>
<p>The supported units are:
    day: Rounds up to the next day if there are any hours/minutes/etc.
    hour: Rounds up to the next hour if there are any minutes/etc.
    minute: Rounds up to the next minute if there are any seconds/etc.
    second: Rounds up to the next second if there are any milliseconds/etc.
    millisecond: Rounds up to the next millisecond if there are any microseconds
    microsecond: Rounds up to the next microsecond if there are any nanoseconds</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The name of a new column with the result. Optional.
If not provided, the result is updated in place.
In strict mode, if provided, the output_column must not exist in the input dataframe.
In non-strict mode, if provided, the output_column with overwrite a column with
the same name in the input dataframe (if any).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, overwriting existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeRoundUpRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Rounds up a set of datetime columns to the specified granularity (day, hour, minute, etc.).</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # rounds the A column to the nearest second</span>
<span class="sd">        rule = DateTimeRoundUpRule(&quot;A&quot;, &quot;second&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # rounds A column to days</span>
<span class="sd">        rule = DateTimeRoundUpRule(&quot;A&quot;, &quot;day&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The column name to round according to the unit specified.</span>
<span class="sd">        unit (str): Specifies the unit of rounding.</span>
<span class="sd">            That is: rounding to the nearest day, hour, minute, etc.</span>

<span class="sd">            The supported units are:</span>
<span class="sd">                day: Rounds up to the next day if there are any hours/minutes/etc.</span>
<span class="sd">                hour: Rounds up to the next hour if there are any minutes/etc.</span>
<span class="sd">                minute: Rounds up to the next minute if there are any seconds/etc.</span>
<span class="sd">                second: Rounds up to the next second if there are any milliseconds/etc.</span>
<span class="sd">                millisecond: Rounds up to the next millisecond if there are any microseconds</span>
<span class="sd">                microsecond: Rounds up to the next microsecond if there are any nanoseconds</span>

<span class="sd">        output_column (Optional[str]): The name of a new column with the result. Optional.</span>
<span class="sd">            If not provided, the result is updated in place.</span>
<span class="sd">            In strict mode, if provided, the output_column must not exist in the input dataframe.</span>
<span class="sd">            In non-strict mode, if provided, the output_column with overwrite a column with</span>
<span class="sd">            the same name in the input dataframe (if any).</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, overwriting existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">ROUND_TRUNC_UNITS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;unit must be one of </span><span class="si">{</span><span class="n">ROUND_TRUNC_UNITS</span><span class="si">}</span><span class="s2"> and not &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeSubstractRule" class="doc doc-heading">
        <code>
DateTimeSubstractRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeSubstractRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Substracts a number of units (days, hours, minutes, etc.) from a datetime column.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># substracts 2 days the A column
rule = DateTimeSubstractRule(&quot;A&quot;, 2, &quot;days&quot;)
rule.apply(data)

# substracts 2 hours to the A column
rule = DateTimeSubstractRule(&quot;A&quot;, 2, &quot;hours&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The name of a datetime column to add to.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit_value</code></td>
        <td><code>Union[int,float,str]</code></td>
        <td><p>The number of units to add to the datetime column.
The unit_value can be negative, in which case this rule performs an addition.</p>
<p>A name of an existing column can be passed into unit_value, in which case, that
column will be substracted from the input_column.
If the column is a timedelta, it will be substracted as is, if it's a numeric column,
then it will be interpreted based on the unit parameter (e.g. days/hours/etc.).
In this case, if the column specified in the unit_value doesn't exist,
MissingColumnError is raised.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>unit</code></td>
        <td><code>str</code></td>
        <td><p>Specifies what unit the unit_value is in. Supported values are:
days, hours, minutes, seconds, microseconds, nanoseconds.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The name of a new column with the result. Optional.
If not provided, the result is updated in place.
In strict mode, if provided, the output_column must not exist in the input dataframe.
In non-strict mode, if provided, the output_column with overwrite a column with
the same name in the input dataframe (if any).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if unit_value is a name of a column but it doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, missing columns or overwriting existing columns are ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeSubstractRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Substracts a number of units (days, hours, minutes, etc.) from a datetime column.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # substracts 2 days the A column</span>
<span class="sd">        rule = DateTimeSubstractRule(&quot;A&quot;, 2, &quot;days&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # substracts 2 hours to the A column</span>
<span class="sd">        rule = DateTimeSubstractRule(&quot;A&quot;, 2, &quot;hours&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The name of a datetime column to add to.</span>
<span class="sd">        unit_value (Union[int,float,str]): The number of units to add to the datetime column.</span>
<span class="sd">            The unit_value can be negative, in which case this rule performs an addition.</span>

<span class="sd">            A name of an existing column can be passed into unit_value, in which case, that</span>
<span class="sd">            column will be substracted from the input_column.</span>
<span class="sd">            If the column is a timedelta, it will be substracted as is, if it&#39;s a numeric column,</span>
<span class="sd">            then it will be interpreted based on the unit parameter (e.g. days/hours/etc.).</span>
<span class="sd">            In this case, if the column specified in the unit_value doesn&#39;t exist,</span>
<span class="sd">            MissingColumnError is raised.</span>

<span class="sd">        unit (str): Specifies what unit the unit_value is in. Supported values are:</span>
<span class="sd">            days, hours, minutes, seconds, microseconds, nanoseconds.</span>

<span class="sd">        output_column (Optional[str]): The name of a new column with the result. Optional.</span>
<span class="sd">            If not provided, the result is updated in place.</span>
<span class="sd">            In strict mode, if provided, the output_column must not exist in the input dataframe.</span>
<span class="sd">            In non-strict mode, if provided, the output_column with overwrite a column with</span>
<span class="sd">            the same name in the input dataframe (if any).</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        MissingColumnError: raised if unit_value is a name of a column but it doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, missing columns or overwriting existing columns are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> 
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;years&quot;</span><span class="p">,</span> <span class="s2">&quot;months&quot;</span><span class="p">,</span> <span class="s2">&quot;weeks&quot;</span><span class="p">,</span> <span class="s2">&quot;weekdays&quot;</span><span class="p">,</span> <span class="s2">&quot;days&quot;</span><span class="p">,</span> <span class="s2">&quot;hours&quot;</span><span class="p">,</span> <span class="s2">&quot;minutes&quot;</span><span class="p">,</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span> <span class="s2">&quot;milliseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;microseconds&quot;</span><span class="p">,</span> <span class="s2">&quot;nanoseconds&quot;</span><span class="p">]],</span>
                 <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_value</span> <span class="o">=</span> <span class="n">unit_value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="n">DT_ARITHMETIC_UNITS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unsupported unit: &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;. It must be one of </span><span class="si">{</span><span class="n">DT_ARITHMETIC_UNITS</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeToStrFormatRule" class="doc doc-heading">
        <code>
DateTimeToStrFormatRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeToStrFormatRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Formats a datetime column to a string representation according to a specified format.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code># displays the dates in column col_A in the %Y-%m-%d format, e.g. 2023-05-19
rule = DateTimeToStrFormatRule(&quot;col_A&quot;, format=&quot;%Y-%m-%d&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The datetime column with the values to format to string.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>format</code></td>
        <td><code>str</code></td>
        <td><p>The format used to display the date/time.
E.g. %Y-%m-%d
For the directives accepted in the format, have a look at:
https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional column to hold the formatted results.
If provided, the existing column is unchanged, and a new column with this new
is created.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, overwriting existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeToStrFormatRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Formats a datetime column to a string representation according to a specified format.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # displays the dates in column col_A in the %Y-%m-%d format, e.g. 2023-05-19</span>
<span class="sd">        rule = DateTimeToStrFormatRule(&quot;col_A&quot;, format=&quot;%Y-%m-%d&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The datetime column with the values to format to string.</span>
<span class="sd">        format: The format used to display the date/time.</span>
<span class="sd">            E.g. %Y-%m-%d</span>
<span class="sd">            For the directives accepted in the format, have a look at:</span>
<span class="sd">            https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior</span>
<span class="sd">        output_column (Optional[str]): An optional column to hold the formatted results.</span>
<span class="sd">            If provided, the existing column is unchanged, and a new column with this new</span>
<span class="sd">            is created.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, overwriting existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.datetime.DateTimeUTCNowRule" class="doc doc-heading">
        <code>
DateTimeUTCNowRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.datetime.DateTimeUTCNowRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Adds a new column with the UTC date/time.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = DateTimeUTCNowRule(output_column=&quot;UTCTimeNow&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>output_column</code></td>
        <td></td>
        <td><p>The name of the column to be added to the dataframe.
This column will be populated with the UTC date/time at the time of the call.
The same value will be populated for all rows.
The date/time populated is a "naive" datetime ie: doesn't have a timezone information.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the input dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, if the output_column exists in the input dataframe, it will be overwritten.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/datetime.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DateTimeUTCNowRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Adds a new column with the UTC date/time.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        rule = DateTimeUTCNowRule(output_column=&quot;UTCTimeNow&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        output_column: The name of the column to be added to the dataframe.</span>
<span class="sd">            This column will be populated with the UTC date/time at the time of the call.</span>
<span class="sd">            The same value will be populated for all rows.</span>
<span class="sd">            The date/time populated is a &quot;naive&quot; datetime ie: doesn&#39;t have a timezone information.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the input dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, if the output_column exists in the input dataframe, it will be overwritten.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">output_column</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_column</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="o">=</span> <span class="n">output_column</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>







  </div>

    </div>

  </div>




  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.fill" class="doc doc-heading">
        <code>fill</code>



<a href="#etlrules.backends.common.fill" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.fill.BackFillRule" class="doc doc-heading">
        <code>
BackFillRule            (<span title="etlrules.backends.common.fill.BaseFillRule">BaseFillRule</span>)
        </code>



<a href="#etlrules.backends.common.fill.BackFillRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| a   | NA |
| b   | 2  |
| a   | NA |
</code></pre></div></td></tr></table></div>
<p>After a fill forward::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| a   | 2  |
| b   | 2  |
| a   | NA |
</code></pre></div></td></tr></table></div>
<p>After a fill forward with group_by=["A"]::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| a   | NA |
| b   | 2  |
| a   | NA |
</code></pre></div></td></tr></table></div>
<p>The "a" group has no non-NA value, so it is not filled.
The "b" group has a non-NA value of 2 but not other NA values, so nothing to fill.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>columns</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>The list of columns to replaces NAs for.
The rest of the columns in the dataframe are not affected.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sort_by</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>The list of columns to sort by before the fill operation. Optional.
Given the previous non-NA values are used, sorting can make a difference in the values uses.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sort_ascending</code></td>
        <td><code>bool</code></td>
        <td><p>When sort_by is specified, True means sort ascending, False sort descending.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>group_by</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>The list of columns to group by before the fill operation. Optional.
The fill values are only used within a group, other adjacent groups are not filled.
Useful when you want to copy(fill) data at a certain group level.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/fill.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BackFillRule</span><span class="p">(</span><span class="n">BaseFillRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data.</span>

<span class="sd">    Example::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | NA |</span>
<span class="sd">        | b   | 2  |</span>
<span class="sd">        | a   | NA |</span>

<span class="sd">    After a fill forward::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | 2  |</span>
<span class="sd">        | b   | 2  |</span>
<span class="sd">        | a   | NA |  </span>

<span class="sd">    After a fill forward with group_by=[&quot;A&quot;]::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | NA |</span>
<span class="sd">        | b   | 2  |</span>
<span class="sd">        | a   | NA |</span>

<span class="sd">    The &quot;a&quot; group has no non-NA value, so it is not filled.</span>
<span class="sd">    The &quot;b&quot; group has a non-NA value of 2 but not other NA values, so nothing to fill.</span>

<span class="sd">    Args:</span>
<span class="sd">        columns (Iterable[str]): The list of columns to replaces NAs for.</span>
<span class="sd">            The rest of the columns in the dataframe are not affected.</span>
<span class="sd">        sort_by (Optional[Iterable[str]]): The list of columns to sort by before the fill operation. Optional.</span>
<span class="sd">            Given the previous non-NA values are used, sorting can make a difference in the values uses.</span>
<span class="sd">        sort_ascending (bool): When sort_by is specified, True means sort ascending, False sort descending.</span>
<span class="sd">        group_by (Optional[Iterable[str]]): The list of columns to group by before the fill operation. Optional.</span>
<span class="sd">            The fill values are only used within a group, other adjacent groups are not filled.</span>
<span class="sd">            Useful when you want to copy(fill) data at a certain group level.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>




  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.fill.ForwardFillRule" class="doc doc-heading">
        <code>
ForwardFillRule            (<span title="etlrules.backends.common.fill.BaseFillRule">BaseFillRule</span>)
        </code>



<a href="#etlrules.backends.common.fill.ForwardFillRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| a   | 1  |
| b   | NA |
| a   | NA |
</code></pre></div></td></tr></table></div>
<p>After a fill forward::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| a   | 1  |
| b   | 1  |
| a   | 1  |
</code></pre></div></td></tr></table></div>
<p>After a fill forward with group_by=["A"]::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  |
| a   | 1  |
| b   | NA |
| a   | 1  |
</code></pre></div></td></tr></table></div>
<p>The "a" group has the first non-NA value as 1 and that is used "forward" to fill the 3rd row.
The "b" group has no non-NA values, so nothing to fill.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>columns</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>The list of columns to replaces NAs for.
The rest of the columns in the dataframe are not affected.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sort_by</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>The list of columns to sort by before the fill operation. Optional.
Given the previous non-NA values are used, sorting can make a difference in the values uses.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sort_ascending</code></td>
        <td><code>bool</code></td>
        <td><p>When sort_by is specified, True means sort ascending, False sort descending.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>group_by</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>The list of columns to group by before the fill operation. Optional.
The fill values are only used within a group, other adjacent groups are not filled.
Useful when you want to copy(fill) data at a certain group level.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/fill.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ForwardFillRule</span><span class="p">(</span><span class="n">BaseFillRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Replaces NAs/missing values with the next non-NA value, optionally sorting and grouping the data.</span>

<span class="sd">    Example::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | 1  |</span>
<span class="sd">        | b   | NA |</span>
<span class="sd">        | a   | NA |</span>

<span class="sd">    After a fill forward::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | 1  |</span>
<span class="sd">        | b   | 1  |</span>
<span class="sd">        | a   | 1  |  </span>

<span class="sd">    After a fill forward with group_by=[&quot;A&quot;]::</span>

<span class="sd">        | A   | B  |</span>
<span class="sd">        | a   | 1  |</span>
<span class="sd">        | b   | NA |</span>
<span class="sd">        | a   | 1  |</span>

<span class="sd">    The &quot;a&quot; group has the first non-NA value as 1 and that is used &quot;forward&quot; to fill the 3rd row.</span>
<span class="sd">    The &quot;b&quot; group has no non-NA values, so nothing to fill.</span>

<span class="sd">    Args:</span>
<span class="sd">        columns (Iterable[str]): The list of columns to replaces NAs for.</span>
<span class="sd">            The rest of the columns in the dataframe are not affected.</span>
<span class="sd">        sort_by (Optional[Iterable[str]]): The list of columns to sort by before the fill operation. Optional.</span>
<span class="sd">            Given the previous non-NA values are used, sorting can make a difference in the values uses.</span>
<span class="sd">        sort_ascending (bool): When sort_by is specified, True means sort ascending, False sort descending.</span>
<span class="sd">        group_by (Optional[Iterable[str]]): The list of columns to group by before the fill operation. Optional.</span>
<span class="sd">            The fill values are only used within a group, other adjacent groups are not filled.</span>
<span class="sd">            Useful when you want to copy(fill) data at a certain group level.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description Optional[str]: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if any columns specified in either columns, sort_by or group_by are missing from the dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.io" class="doc doc-heading">
        <code>io</code>


  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#etlrules.backends.common.io" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">










  <div class="doc doc-object doc-module">



<h5 id="etlrules.backends.common.io.db" class="doc doc-heading">
        <code>db</code>



<a href="#etlrules.backends.common.io.db" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h6 id="etlrules.backends.common.io.db.ReadSQLQueryRule" class="doc doc-heading">
        <code>
ReadSQLQueryRule            (<span title="etlrules.rule.BaseRule">BaseRule</span>)
        </code>



<a href="#etlrules.backends.common.io.db.ReadSQLQueryRule" class="headerlink" title="Permanent link">&para;</a></h6>

    <div class="doc doc-contents ">

      <p>Runs a SQL query and reads the results back into a dataframe.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code># reads all the data from a sqlite db called mydb.db, from the table MyTable
# saves the dataframe as the main output of the rule which subsequent rules can use as their main input
rule = ReadSQLQueryRule(&quot;sqlite:///mydb.db&quot;, &quot;SELECT * FROM MyTable&quot;)
rule.apply(data)

# reads all the data from a sqlite db called mydb.db, from the table MyTable
# saves the dataframe as the a named output called MyData which subsequent rules can use by name
rule = ReadSQLQueryRule(&quot;sqlite:///mydb.db&quot;, &quot;SELECT * FROM MyTable&quot;, named_output=&quot;MyData&quot;)
rule.apply(data)

# same as the first example, but uses column types rather than relying on type inferrence
rule = ReadSQLQueryRule(&quot;sqlite:///mydb.db&quot;, &quot;SELECT * FROM MyTable&quot;, column_types={&quot;ColA&quot;: &quot;int64&quot;, &quot;ColB&quot;: &quot;string&quot;})
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sql_engine</code></td>
        <td><code>str</code></td>
        <td><p>A sqlalchemy engine string. This is typically in the form:
dialect+driver://username:password@host:port/database
For more information, please refer to the sqlalchemy documentation here:
https://docs.sqlalchemy.org/en/20/core/engines.html</p>
<p>In order to support users and passwords in the sql_engine string, substitutions of environment variables
is supported using the {env.VARIABLE_NAME} form.
For example, adding the USER and PASSWORD environment variables in the sql string could be done as:
    sql_engine = "postgres://{env.USER}:{env.PASSWORD}@{env.DB_HOST}/mydb
In this example, when you run, env.USER, env.PASSWORD and env.DB_HOST will be replaced with the respective
environment variables, allowing you to not hardcode them in the plan for security reasons but also for
configurability.
A similar substition can be achieved using the plan context using the context.property, e.g.
    sql_engine = "postgres://{context.USER}:{env.PASSWORD}@{context.DB_HOST}/mydb
It's not recommended to store passwords in plain text in the plan.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sql_query</code></td>
        <td><code>str</code></td>
        <td><p>A SQL SELECT statement that will specify the columns, table and optionally any WHERE, GROUP BY, ORDER BY clauses.
The SQL statement must be valid for the SQL engine specified in the sql_engine parameter.</p>
<p>The env and context substitution work in the sql_query too. E.g.:
    SELECT * from {env.SCHEMA}.{context.TABLE_NAME} WHERE {context.FILTER}
This allows you to parameterize the plan at run time.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_types</code></td>
        <td><code>Optional[Mapping[str, str]]</code></td>
        <td><p>A mapping of column names and their types. Column types are inferred from the data when this parameter
is not specified. For empty result sets, this inferrence is not possible, so specifying the column types allows
the users to control the types in that scenario and not fallback onto backends defaults. </p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>SQLError</code></td>
        <td><p>raised if there's an error running the sql statement.</p></td>
      </tr>
      <tr>
        <td><code>UnsupportedTypeError</code></td>
        <td><p>raised if column_types are specified and any of them are not supported.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation uses sqlalchemy, which must be installed as an optional dependency of etlrules.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/io/db.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ReadSQLQueryRule</span><span class="p">(</span><span class="n">BaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Runs a SQL query and reads the results back into a dataframe.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # reads all the data from a sqlite db called mydb.db, from the table MyTable</span>
<span class="sd">        # saves the dataframe as the main output of the rule which subsequent rules can use as their main input</span>
<span class="sd">        rule = ReadSQLQueryRule(&quot;sqlite:///mydb.db&quot;, &quot;SELECT * FROM MyTable&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # reads all the data from a sqlite db called mydb.db, from the table MyTable</span>
<span class="sd">        # saves the dataframe as the a named output called MyData which subsequent rules can use by name</span>
<span class="sd">        rule = ReadSQLQueryRule(&quot;sqlite:///mydb.db&quot;, &quot;SELECT * FROM MyTable&quot;, named_output=&quot;MyData&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # same as the first example, but uses column types rather than relying on type inferrence</span>
<span class="sd">        rule = ReadSQLQueryRule(&quot;sqlite:///mydb.db&quot;, &quot;SELECT * FROM MyTable&quot;, column_types={&quot;ColA&quot;: &quot;int64&quot;, &quot;ColB&quot;: &quot;string&quot;})</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        sql_engine: A sqlalchemy engine string. This is typically in the form:</span>
<span class="sd">            dialect+driver://username:password@host:port/database</span>
<span class="sd">            For more information, please refer to the sqlalchemy documentation here:</span>
<span class="sd">            https://docs.sqlalchemy.org/en/20/core/engines.html</span>

<span class="sd">            In order to support users and passwords in the sql_engine string, substitutions of environment variables</span>
<span class="sd">            is supported using the {env.VARIABLE_NAME} form.</span>
<span class="sd">            For example, adding the USER and PASSWORD environment variables in the sql string could be done as:</span>
<span class="sd">                sql_engine = &quot;postgres://{env.USER}:{env.PASSWORD}@{env.DB_HOST}/mydb</span>
<span class="sd">            In this example, when you run, env.USER, env.PASSWORD and env.DB_HOST will be replaced with the respective</span>
<span class="sd">            environment variables, allowing you to not hardcode them in the plan for security reasons but also for</span>
<span class="sd">            configurability.</span>
<span class="sd">            A similar substition can be achieved using the plan context using the context.property, e.g.</span>
<span class="sd">                sql_engine = &quot;postgres://{context.USER}:{env.PASSWORD}@{context.DB_HOST}/mydb</span>
<span class="sd">            It&#39;s not recommended to store passwords in plain text in the plan.</span>
<span class="sd">        sql_query: A SQL SELECT statement that will specify the columns, table and optionally any WHERE, GROUP BY, ORDER BY clauses.</span>
<span class="sd">            The SQL statement must be valid for the SQL engine specified in the sql_engine parameter.</span>

<span class="sd">            The env and context substitution work in the sql_query too. E.g.:</span>
<span class="sd">                SELECT * from {env.SCHEMA}.{context.TABLE_NAME} WHERE {context.FILTER}</span>
<span class="sd">            This allows you to parameterize the plan at run time.</span>
<span class="sd">        column_types: A mapping of column names and their types. Column types are inferred from the data when this parameter</span>
<span class="sd">            is not specified. For empty result sets, this inferrence is not possible, so specifying the column types allows</span>
<span class="sd">            the users to control the types in that scenario and not fallback onto backends defaults. </span>

<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        SQLError: raised if there&#39;s an error running the sql statement.</span>
<span class="sd">        UnsupportedTypeError: raised if column_types are specified and any of them are not supported.</span>

<span class="sd">    Note:</span>
<span class="sd">        The implementation uses sqlalchemy, which must be installed as an optional dependency of etlrules.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sql_engine</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sql_query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">column_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span> <span class="o">=</span> <span class="n">sql_engine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sql_query</span> <span class="o">=</span> <span class="n">sql_query</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_engine parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sql_query</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_query</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_query parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="n">column_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_column_types</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_validate_column_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">column_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">column_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_TYPES</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">UnsupportedTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type &#39;</span><span class="si">{</span><span class="n">column_type</span><span class="si">}</span><span class="s2">&#39; for column &#39;</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">&#39; is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_do_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t instantiate base class.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_sql_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">sql_engine</span> <span class="o">=</span> <span class="n">subst_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sql_engine</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_engine parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sql_engine</span>

    <span class="k">def</span> <span class="nf">_get_sql_query</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">sql_query</span> <span class="o">=</span> <span class="n">subst_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_query</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sql_query</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_query parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sql_query</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">sql_engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sql_engine</span><span class="p">()</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="n">SQLAlchemyEngines</span><span class="o">.</span><span class="n">get_engine</span><span class="p">(</span><span class="n">sql_engine</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">connection</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_apply</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sa</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">SQLAlchemyError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SQLError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>




  <div class="doc doc-object doc-class">



<h6 id="etlrules.backends.common.io.db.WriteSQLTableRule" class="doc doc-heading">
        <code>
WriteSQLTableRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.io.db.WriteSQLTableRule" class="headerlink" title="Permanent link">&para;</a></h6>

    <div class="doc doc-contents ">

      <p>Writes the data from the input dataframe into a SQL table in a database.</p>
<p>The rule is a final rule, which means it produces no additional outputs, it takes any of the existing
outputs and writes it to the DB. If the named_input is specified, the input with that name
is written, otherwise, it takes the main output of the preceding rule.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code># writes the main input to a table called MyTable in a sqlite DB called mydb.db
# If the table already exists, it replaces it
rule = WriteSQLTableRule(&quot;sqlite:///mydb.db&quot;, &quot;MyTable&quot;, if_exists=&quot;replace&quot;)
rule.apply(data)

# writes the dataframe input called &#39;input_data&#39; to a table MyTable in a sqlite DB mydb.db
# If the table already exists, it appends the data to it
rule = WriteSQLTableRule(&quot;sqlite:///mydb.db&quot;, &quot;MyTable&quot;, if_exists=&quot;append&quot;, named_input=&quot;input_data&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sql_engine</code></td>
        <td><code>str</code></td>
        <td><p>A sqlalchemy engine string. This is typically in the form:
dialect+driver://username:password@host:port/database
For more information, please refer to the sqlalchemy documentation here:
https://docs.sqlalchemy.org/en/20/core/engines.html</p>
<p>In order to support users and passwords in the sql_engine string, substitutions of environment variables
is supported using the {env.VARIABLE_NAME} form.
For example, adding the USER and PASSWORD environment variables in the sql string could be done as:
    sql_engine = "postgres://{env.USER}:{env.PASSWORD}@{env.DB_HOST}/mydb
In this example, when you run, env.USER, env.PASSWORD and env.DB_HOST will be replaced with the respective
environment variables, allowing you to not hardcode them in the plan for security reasons but also for
configurability. </p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sql_table</code></td>
        <td><code>str</code></td>
        <td><p>The name of the sql table to write to.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>if_exists</code></td>
        <td><code>str</code></td>
        <td><p>Specifies what to do in case the table already exists in the database.
The options are:
    - replace: drops all the existing data and inserts the data in the input dataframe
    - append: adds the data in the input dataframe to the existing data in the table
    - fail: Raises a ValueError exception
Default: fail.</p></td>
        <td><code>&#39;fail&#39;</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Select by name the dataframe to write from the input data.
Optional. When not specified, the main output of the previous rule will be written.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raised if the table already exists when the if_exists is fail.
ValueError is also raised if any of the arguments passed into the rule are not strings or empty strings.</p></td>
      </tr>
      <tr>
        <td><code>SQLError</code></td>
        <td><p>raised if there's any problem writing the data into the database.
For example: If the schema doesn't match the schema of the table written to (for existing tables).</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/io/db.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">WriteSQLTableRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Writes the data from the input dataframe into a SQL table in a database.</span>

<span class="sd">    The rule is a final rule, which means it produces no additional outputs, it takes any of the existing</span>
<span class="sd">    outputs and writes it to the DB. If the named_input is specified, the input with that name</span>
<span class="sd">    is written, otherwise, it takes the main output of the preceding rule.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # writes the main input to a table called MyTable in a sqlite DB called mydb.db</span>
<span class="sd">        # If the table already exists, it replaces it</span>
<span class="sd">        rule = WriteSQLTableRule(&quot;sqlite:///mydb.db&quot;, &quot;MyTable&quot;, if_exists=&quot;replace&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # writes the dataframe input called &#39;input_data&#39; to a table MyTable in a sqlite DB mydb.db</span>
<span class="sd">        # If the table already exists, it appends the data to it</span>
<span class="sd">        rule = WriteSQLTableRule(&quot;sqlite:///mydb.db&quot;, &quot;MyTable&quot;, if_exists=&quot;append&quot;, named_input=&quot;input_data&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        sql_engine: A sqlalchemy engine string. This is typically in the form:</span>
<span class="sd">            dialect+driver://username:password@host:port/database</span>
<span class="sd">            For more information, please refer to the sqlalchemy documentation here:</span>
<span class="sd">            https://docs.sqlalchemy.org/en/20/core/engines.html</span>

<span class="sd">            In order to support users and passwords in the sql_engine string, substitutions of environment variables</span>
<span class="sd">            is supported using the {env.VARIABLE_NAME} form.</span>
<span class="sd">            For example, adding the USER and PASSWORD environment variables in the sql string could be done as:</span>
<span class="sd">                sql_engine = &quot;postgres://{env.USER}:{env.PASSWORD}@{env.DB_HOST}/mydb</span>
<span class="sd">            In this example, when you run, env.USER, env.PASSWORD and env.DB_HOST will be replaced with the respective</span>
<span class="sd">            environment variables, allowing you to not hardcode them in the plan for security reasons but also for</span>
<span class="sd">            configurability. </span>
<span class="sd">        sql_table: The name of the sql table to write to.</span>
<span class="sd">        if_exists: Specifies what to do in case the table already exists in the database.</span>
<span class="sd">            The options are:</span>
<span class="sd">                - replace: drops all the existing data and inserts the data in the input dataframe</span>
<span class="sd">                - append: adds the data in the input dataframe to the existing data in the table</span>
<span class="sd">                - fail: Raises a ValueError exception</span>
<span class="sd">            Default: fail.</span>

<span class="sd">        named_input (Optional[str]): Select by name the dataframe to write from the input data.</span>
<span class="sd">            Optional. When not specified, the main output of the previous rule will be written.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: raised if the table already exists when the if_exists is fail.</span>
<span class="sd">            ValueError is also raised if any of the arguments passed into the rule are not strings or empty strings.</span>
<span class="sd">        SQLError: raised if there&#39;s any problem writing the data into the database.</span>
<span class="sd">            For example: If the schema doesn&#39;t match the schema of the table written to (for existing tables).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">IF_EXISTS_OPTIONS</span><span class="p">:</span>
        <span class="n">APPEND</span> <span class="o">=</span> <span class="s1">&#39;append&#39;</span>
        <span class="n">REPLACE</span> <span class="o">=</span> <span class="s1">&#39;replace&#39;</span>
        <span class="n">FAIL</span> <span class="o">=</span> <span class="s1">&#39;fail&#39;</span>

    <span class="n">ALL_IF_EXISTS_OPTIONS</span> <span class="o">=</span> <span class="p">{</span><span class="n">IF_EXISTS_OPTIONS</span><span class="o">.</span><span class="n">APPEND</span><span class="p">,</span> <span class="n">IF_EXISTS_OPTIONS</span><span class="o">.</span><span class="n">REPLACE</span><span class="p">,</span> <span class="n">IF_EXISTS_OPTIONS</span><span class="o">.</span><span class="n">FAIL</span><span class="p">}</span>

    <span class="n">EXCLUDE_FROM_SERIALIZE</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;named_output&quot;</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sql_engine</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sql_table</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">if_exists</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;fail&#39;</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span> <span class="o">=</span> <span class="n">sql_engine</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_engine parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sql_table</span> <span class="o">=</span> <span class="n">sql_table</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sql_table</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_table</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_table parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">if_exists</span> <span class="o">=</span> <span class="n">if_exists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_exists</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ALL_IF_EXISTS_OPTIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">if_exists</span><span class="si">}</span><span class="s2">&#39; is not a valid value for the if_exists parameter. It must be one of: &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ALL_IF_EXISTS_OPTIONS</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_sql_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">sql_engine</span> <span class="o">=</span> <span class="n">subst_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_engine</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sql_engine</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_engine parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sql_engine</span>

    <span class="k">def</span> <span class="nf">_get_sql_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">sql_table</span> <span class="o">=</span> <span class="n">subst_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql_table</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sql_table</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sql_table parameter must be a non-empty string.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sql_table</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">
















  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h5 id="etlrules.backends.common.io.files" class="doc doc-heading">
        <code>files</code>



<a href="#etlrules.backends.common.io.files" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">




  <div class="doc doc-children">









  <div class="doc doc-object doc-class">



<h6 id="etlrules.backends.common.io.files.ReadCSVFileRule" class="doc doc-heading">
        <code>
ReadCSVFileRule            (<span title="etlrules.backends.common.io.files.BaseReadFileRule">BaseReadFileRule</span>)
        </code>



<a href="#etlrules.backends.common.io.files.ReadCSVFileRule" class="headerlink" title="Permanent link">&para;</a></h6>

    <div class="doc doc-contents ">

      <p>Reads one or multiple csv files from a directory and persists it as a dataframe for subsequent rules to operate on.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code># reads a file data.csv and persists it as the main output of the rule
rule = ReadCSVFileRule(&quot;data.csv&quot;, &quot;/home/myuser/&quot;)
rule.apply(data)

# reads a file test_data.csv and persists it as the input_data named output
# other rules can specify input_data as their named_input to operate on it
rule = ReadCSVFileRule(&quot;test_data.csv&quot;, &quot;/home/myuser/&quot;, named_output=&quot;input_data&quot;)
rule.apply(data)

# extracts all files starting with data followed by 4 digits and concatenate them
# e.g. data1234.csv, data5678.csv, etc.
rule = ReadCSVFileRule(&quot;data[0-9]{4}.csv&quot;, &quot;/home/myuser/&quot;, regex=True, named_output=&quot;input_data&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>file_name</code></td>
        <td><code>str</code></td>
        <td><p>The name of the csv file to load. The format will be inferred from the extension of the file.
A simple text csv file will be inferred from the .csv extension. The extensions like .zip, .gz, .bz2, .xz
will extract a single compressed csv file from the given input compressed file.
file_name can also be a regular expression (specify regex=True in that case).
The reader will find all the files in the file_dir directory that match the regular expression and extract
all those csv file and concatenate them into a single dataframe.
For example, file_name=".*.csv", file_dir=".", regex=True will extract all the files with the .csv extension
from the current directory.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>file_dir</code></td>
        <td><code>str</code></td>
        <td><p>The file directory where the file_name is located. When file_name is a regular expression and 
the regex parameter is True, file_dir is the directory that is inspected for any files that match the
regular expression.
Defaults to . (ie the current directory).</p></td>
        <td><code>&#39;.&#39;</code></td>
      </tr>
      <tr>
        <td><code>regex</code></td>
        <td><code>bool</code></td>
        <td><p>When True, the file_name is interpreted as a regular expression. Defaults to False.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>separator</code></td>
        <td><code>str</code></td>
        <td><p>The single character to be used as separator in the csv file. Defaults to , (comma).</p></td>
        <td><code>&#39;,&#39;</code></td>
      </tr>
      <tr>
        <td><code>header</code></td>
        <td><code>bool</code></td>
        <td><p>When True, the first line is interpreted as the header and the column names are extracted from it.
When False, the first line is part of the data and the columns will have names like 0, 1, 2, etc.
Defaults to True.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>IOError</code></td>
        <td><p>raised when the file is not found.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/io/files.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ReadCSVFileRule</span><span class="p">(</span><span class="n">BaseReadFileRule</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Reads one or multiple csv files from a directory and persists it as a dataframe for subsequent rules to operate on.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # reads a file data.csv and persists it as the main output of the rule</span>
<span class="sd">        rule = ReadCSVFileRule(&quot;data.csv&quot;, &quot;/home/myuser/&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # reads a file test_data.csv and persists it as the input_data named output</span>
<span class="sd">        # other rules can specify input_data as their named_input to operate on it</span>
<span class="sd">        rule = ReadCSVFileRule(&quot;test_data.csv&quot;, &quot;/home/myuser/&quot;, named_output=&quot;input_data&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # extracts all files starting with data followed by 4 digits and concatenate them</span>
<span class="sd">        # e.g. data1234.csv, data5678.csv, etc.</span>
<span class="sd">        rule = ReadCSVFileRule(&quot;data[0-9]{4}.csv&quot;, &quot;/home/myuser/&quot;, regex=True, named_output=&quot;input_data&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name: The name of the csv file to load. The format will be inferred from the extension of the file.</span>
<span class="sd">            A simple text csv file will be inferred from the .csv extension. The extensions like .zip, .gz, .bz2, .xz</span>
<span class="sd">            will extract a single compressed csv file from the given input compressed file.</span>
<span class="sd">            file_name can also be a regular expression (specify regex=True in that case).</span>
<span class="sd">            The reader will find all the files in the file_dir directory that match the regular expression and extract</span>
<span class="sd">            all those csv file and concatenate them into a single dataframe.</span>
<span class="sd">            For example, file_name=&quot;.*\.csv&quot;, file_dir=&quot;.&quot;, regex=True will extract all the files with the .csv extension</span>
<span class="sd">            from the current directory.</span>
<span class="sd">        file_dir: The file directory where the file_name is located. When file_name is a regular expression and </span>
<span class="sd">            the regex parameter is True, file_dir is the directory that is inspected for any files that match the</span>
<span class="sd">            regular expression.</span>
<span class="sd">            Defaults to . (ie the current directory).</span>
<span class="sd">        regex: When True, the file_name is interpreted as a regular expression. Defaults to False.</span>
<span class="sd">        separator: The single character to be used as separator in the csv file. Defaults to , (comma).</span>
<span class="sd">        header: When True, the first line is interpreted as the header and the column names are extracted from it.</span>
<span class="sd">            When False, the first line is part of the data and the columns will have names like 0, 1, 2, etc.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: raised when the file is not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file_dir</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_dir</span><span class="o">=</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">=</span> <span class="n">separator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">header</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h6 id="etlrules.backends.common.io.files.ReadParquetFileRule" class="doc doc-heading">
        <code>
ReadParquetFileRule            (<span title="etlrules.backends.common.io.files.BaseReadFileRule">BaseReadFileRule</span>)
        </code>



<a href="#etlrules.backends.common.io.files.ReadParquetFileRule" class="headerlink" title="Permanent link">&para;</a></h6>

    <div class="doc doc-contents ">

      <p>Reads one or multiple parquet files from a directory and persists it as a dataframe for subsequent rules to operate on.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span></pre></div></td><td class="code"><div><pre><span></span><code># reads a file data.csv and persists it as the main output of the rule
rule = ReadParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;)
rule.apply(data)

# reads a file test_data.parquet and persists it as the input_data named output
# other rules can specify input_data as their named_input to operate on it
rule = ReadParquetFileRule(&quot;test_data.parquet&quot;, &quot;/home/myuser/&quot;, named_output=&quot;input_data&quot;)
rule.apply(data)

# reads all the files with the .parquet extension from the home dir of myuser and
# concatenates them into a single dataframe
rule = ReadParquetFileRule(&quot;.*\.parquet&quot;, &quot;/home/myuser/&quot;, named_output=&quot;input_data&quot;)
rule.apply(data)

# reads only the A,B,C columns from the file data.csv file
rule = ReadParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;, columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])
rule.apply(data)

# reads only those rows where column A is greater than 10 and column B is True
rule = ReadParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;, filters=[[&quot;A&quot;, &quot;&gt;=&quot;, 10], [&quot;B&quot;, &quot;==&quot;, True]])
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>file_name</code></td>
        <td><code>str</code></td>
        <td><p>The name of the parquet file to load. The format will be inferred from the extension of the file.
file_name can also be a regular expression (specify regex=True in that case).
The reader will find all the files in the file_dir directory that match the regular expression and extract
all those parquet file and concatenate them into a single dataframe.
For example, file_name=".*.parquet", file_dir=".", regex=True will extract all the files with the .parquet extension
from the current directory.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>file_dir</code></td>
        <td><code>str</code></td>
        <td><p>The file directory where the file_name is located. When file_name is a regular expression and 
the regex parameter is True, file_dir is the directory that is inspected for any files that match the
regular expression.
Defaults to . (ie the current directory).</p></td>
        <td><code>&#39;.&#39;</code></td>
      </tr>
      <tr>
        <td><code>regex</code></td>
        <td><code>bool</code></td>
        <td><p>When True, the file_name is interpreted as a regular expression. Defaults to False.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>columns</code></td>
        <td><code>Optional[Sequence[str]]</code></td>
        <td><p>A subset of the columns in the parquet file to load.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>filters</code></td>
        <td><code>Union[List[Tuple], List[List[Tuple]]]</code></td>
        <td><p>A list of filters to apply to filter the rows returned. Rows which do not match the filter conditions
will be removed from scanned data.
When passed as a List[List[Tuple]], the conditions in the inner lists are AND-end together with the top level
condition OR-ed together. Eg: ((cond1 AND cond2...) OR (cond3 AND cond4...)...)
When passed as a List[Tuple], the conditions are AND-ed together. E.g.: cond1 AND cond2 AND cond3...
Each condition is specified as a tuple of 3 elements: (column, operation, value).
Column is the name of a column in the input dataframe.
Operation is one of: "==", "=", "&gt;", "&gt;=", "&lt;", "&lt;=", "!=", "in", "not in".
Value is a scalar value, int, float, string, etc. When the operation is in or not in, the value must be a list, tuple or set of values.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>IOError</code></td>
        <td><p>raised when the file is not found.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raised if filters are specified but the format is incorrect.</p></td>
      </tr>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column is specified in columns or filters but it doesn't exist in the input dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>The parquet file can be compressed in which case the compression will be inferred from the file.
The following compression algorithms are supported: "snappy", "gzip", "brotli", "lz4", "zstd".</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/io/files.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ReadParquetFileRule</span><span class="p">(</span><span class="n">BaseReadFileRule</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Reads one or multiple parquet files from a directory and persists it as a dataframe for subsequent rules to operate on.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # reads a file data.csv and persists it as the main output of the rule</span>
<span class="sd">        rule = ReadParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # reads a file test_data.parquet and persists it as the input_data named output</span>
<span class="sd">        # other rules can specify input_data as their named_input to operate on it</span>
<span class="sd">        rule = ReadParquetFileRule(&quot;test_data.parquet&quot;, &quot;/home/myuser/&quot;, named_output=&quot;input_data&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # reads all the files with the .parquet extension from the home dir of myuser and</span>
<span class="sd">        # concatenates them into a single dataframe</span>
<span class="sd">        rule = ReadParquetFileRule(&quot;.*\.parquet&quot;, &quot;/home/myuser/&quot;, named_output=&quot;input_data&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # reads only the A,B,C columns from the file data.csv file</span>
<span class="sd">        rule = ReadParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;, columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # reads only those rows where column A is greater than 10 and column B is True</span>
<span class="sd">        rule = ReadParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;, filters=[[&quot;A&quot;, &quot;&gt;=&quot;, 10], [&quot;B&quot;, &quot;==&quot;, True]])</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name: The name of the parquet file to load. The format will be inferred from the extension of the file.</span>
<span class="sd">            file_name can also be a regular expression (specify regex=True in that case).</span>
<span class="sd">            The reader will find all the files in the file_dir directory that match the regular expression and extract</span>
<span class="sd">            all those parquet file and concatenate them into a single dataframe.</span>
<span class="sd">            For example, file_name=&quot;.*\.parquet&quot;, file_dir=&quot;.&quot;, regex=True will extract all the files with the .parquet extension</span>
<span class="sd">            from the current directory.</span>
<span class="sd">        file_dir: The file directory where the file_name is located. When file_name is a regular expression and </span>
<span class="sd">            the regex parameter is True, file_dir is the directory that is inspected for any files that match the</span>
<span class="sd">            regular expression.</span>
<span class="sd">            Defaults to . (ie the current directory).</span>
<span class="sd">        regex: When True, the file_name is interpreted as a regular expression. Defaults to False.</span>
<span class="sd">        columns: A subset of the columns in the parquet file to load.</span>
<span class="sd">        filters: A list of filters to apply to filter the rows returned. Rows which do not match the filter conditions</span>
<span class="sd">            will be removed from scanned data.</span>
<span class="sd">            When passed as a List[List[Tuple]], the conditions in the inner lists are AND-end together with the top level</span>
<span class="sd">            condition OR-ed together. Eg: ((cond1 AND cond2...) OR (cond3 AND cond4...)...)</span>
<span class="sd">            When passed as a List[Tuple], the conditions are AND-ed together. E.g.: cond1 AND cond2 AND cond3...</span>
<span class="sd">            Each condition is specified as a tuple of 3 elements: (column, operation, value).</span>
<span class="sd">            Column is the name of a column in the input dataframe.</span>
<span class="sd">            Operation is one of: &quot;==&quot;, &quot;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;!=&quot;, &quot;in&quot;, &quot;not in&quot;.</span>
<span class="sd">            Value is a scalar value, int, float, string, etc. When the operation is in or not in, the value must be a list, tuple or set of values.</span>

<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: raised when the file is not found.</span>
<span class="sd">        ValueError: raised if filters are specified but the format is incorrect.</span>
<span class="sd">        MissingColumnError: raised if a column is specified in columns or filters but it doesn&#39;t exist in the input dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        The parquet file can be compressed in which case the compression will be inferred from the file.</span>
<span class="sd">        The following compression algorithms are supported: &quot;snappy&quot;, &quot;gzip&quot;, &quot;brotli&quot;, &quot;lz4&quot;, &quot;zstd&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SUPPORTED_FILTERS_OPS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;!=&quot;</span><span class="p">,</span> <span class="s2">&quot;in&quot;</span><span class="p">,</span> <span class="s2">&quot;not in&quot;</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file_dir</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filters</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_dir</span><span class="o">=</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_filters</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span> <span class="k">if</span> <span class="n">filters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_raise_filters_invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid filters. It must be a List[Tuple] or List[List[Tuple]] with each Tuple being (column, op, value): </span><span class="si">{</span><span class="n">error</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tpl</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tpl</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tpl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tpl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_filters_invalid</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Third level expected a list/tuple (cond, op, value), got: </span><span class="si">{</span><span class="n">tpl</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">tpl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_FILTERS_OPS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_filters_invalid</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid operator </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">tpl</span><span class="si">}</span><span class="s2">. Must be one of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">SUPPORTED_FILTERS_OPS</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">tpl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;in&quot;</span><span class="p">,</span> <span class="s2">&quot;not in&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_filters_invalid</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value type for </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> operand in </span><span class="si">{</span><span class="n">tpl</span><span class="si">}</span><span class="s2">. Must be list/tuple/set.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">tpl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">op</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">filters</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">filter2</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter2</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">filter2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filter2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="c1"># List[Tuple] form</span>
                        <span class="n">tpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_tuple</span><span class="p">(</span><span class="n">filter2</span><span class="p">)</span>
                        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tpl</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lst2</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">filter3</span> <span class="ow">in</span> <span class="n">filter2</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter3</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">filter3</span><span class="p">:</span>
                                <span class="n">tpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_tuple</span><span class="p">(</span><span class="n">filter3</span><span class="p">)</span>
                                <span class="n">lst2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tpl</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_filters_invalid</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Third level expected a list/tuple, got: </span><span class="si">{</span><span class="n">filter3</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_raise_filters_invalid</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Second level expected a list/tuple, got: </span><span class="si">{</span><span class="n">filter2</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">_raise_filters_invalid</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Top level expected a list/tuple, got: </span><span class="si">{</span><span class="n">filters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lst</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h6 id="etlrules.backends.common.io.files.WriteCSVFileRule" class="doc doc-heading">
        <code>
WriteCSVFileRule            (<span title="etlrules.backends.common.io.files.BaseWriteFileRule">BaseWriteFileRule</span>)
        </code>



<a href="#etlrules.backends.common.io.files.WriteCSVFileRule" class="headerlink" title="Permanent link">&para;</a></h6>

    <div class="doc doc-contents ">

      <p>Writes an existing dataframe to a csv file (optionally compressed) on disk.</p>
<p>The rule is a final rule, which means it produces no additional outputs, it takes any of the existing outputs and writes it to disk.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># writes a file data.csv and persists the main output of the previous rule to it
rule = WriteCSVFileRule(&quot;data.csv&quot;, &quot;/home/myuser/&quot;)
rule.apply(data)

# writes a file test_data.csv and persists the dataframe named input_data into it
rule = WriteCSVFileRule(&quot;test_data.csv&quot;, &quot;/home/myuser/&quot;, named_input=&quot;input_data&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>file_name</code></td>
        <td></td>
        <td><p>The name of the csv file to write to disk. It will be written in the directory
specified by the file_dir parameter.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>file_dir</code></td>
        <td></td>
        <td><p>The file directory where the file_name should be written.
Defaults to . (ie the current directory).</p></td>
        <td><code>&#39;.&#39;</code></td>
      </tr>
      <tr>
        <td><code>separator</code></td>
        <td></td>
        <td><p>The single character to separate values in the csv file. Defaults to , (comma).</p></td>
        <td><code>&#39;,&#39;</code></td>
      </tr>
      <tr>
        <td><code>header</code></td>
        <td></td>
        <td><p>When True, the first line will contain the columns separated by the separator.
When False, the columns will not be written and the first line contains data.
Defaults to True.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>compression</code></td>
        <td></td>
        <td><p>Compress the csv file using a supported compression algorithms. Optional.
When the compression is specified, the file_name must end with the extension associate with that
compression format. The following options are supported:
zip - file_name must end with .zip (e.g. output.csv.zip), will produced a zipped csv file
gzip - file_name must end with .gz (e.g. output.csv.gz), will produced a gzipped csv file
bz2 - file_name must end with .bz2 (e.g. output.csv.bz2), will produced a bzipped csv 
xz - file_name must end with .xz (e.g. output.csv.xz), will produced a xz-compressed csv file</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Select by name the dataframe to write from the input data.
Optional. When not specified, the main output of the previous rule will be written.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/io/files.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">WriteCSVFileRule</span><span class="p">(</span><span class="n">BaseWriteFileRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Writes an existing dataframe to a csv file (optionally compressed) on disk.</span>

<span class="sd">    The rule is a final rule, which means it produces no additional outputs, it takes any of the existing outputs and writes it to disk.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # writes a file data.csv and persists the main output of the previous rule to it</span>
<span class="sd">        rule = WriteCSVFileRule(&quot;data.csv&quot;, &quot;/home/myuser/&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # writes a file test_data.csv and persists the dataframe named input_data into it</span>
<span class="sd">        rule = WriteCSVFileRule(&quot;test_data.csv&quot;, &quot;/home/myuser/&quot;, named_input=&quot;input_data&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name: The name of the csv file to write to disk. It will be written in the directory</span>
<span class="sd">            specified by the file_dir parameter.</span>
<span class="sd">        file_dir: The file directory where the file_name should be written.</span>
<span class="sd">            Defaults to . (ie the current directory).</span>
<span class="sd">        separator: The single character to separate values in the csv file. Defaults to , (comma).</span>
<span class="sd">        header: When True, the first line will contain the columns separated by the separator.</span>
<span class="sd">            When False, the columns will not be written and the first line contains data.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        compression: Compress the csv file using a supported compression algorithms. Optional.</span>
<span class="sd">            When the compression is specified, the file_name must end with the extension associate with that</span>
<span class="sd">            compression format. The following options are supported:</span>
<span class="sd">            zip - file_name must end with .zip (e.g. output.csv.zip), will produced a zipped csv file</span>
<span class="sd">            gzip - file_name must end with .gz (e.g. output.csv.gz), will produced a gzipped csv file</span>
<span class="sd">            bz2 - file_name must end with .bz2 (e.g. output.csv.bz2), will produced a bzipped csv </span>
<span class="sd">            xz - file_name must end with .xz (e.g. output.csv.xz), will produced a xz-compressed csv file</span>

<span class="sd">        named_input (Optional[str]): Select by name the dataframe to write from the input data.</span>
<span class="sd">            Optional. When not specified, the main output of the previous rule will be written.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">COMPRESSIONS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;zip&#39;</span><span class="p">:</span> <span class="s1">&#39;.zip&#39;</span><span class="p">,</span>
        <span class="s1">&#39;gzip&#39;</span><span class="p">:</span> <span class="s1">&#39;.gz&#39;</span><span class="p">,</span>
        <span class="s1">&#39;bz2&#39;</span><span class="p">:</span> <span class="s1">&#39;.bz2&#39;</span><span class="p">,</span>
        <span class="s1">&#39;xz&#39;</span><span class="p">:</span> <span class="s1">&#39;.xz&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">file_dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_dir</span><span class="o">=</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> 
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">=</span> <span class="n">separator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">assert</span> <span class="n">compression</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">compression</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">COMPRESSIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;Unsupported compression &#39;</span><span class="si">{</span><span class="n">compression</span><span class="si">}</span><span class="s2">&#39;. It must be one of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">COMPRESSIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="n">compression</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">COMPRESSIONS</span><span class="p">[</span><span class="n">compression</span><span class="p">]),</span> <span class="sa">f</span><span class="s2">&quot;The file name </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> must have the extension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">COMPRESSIONS</span><span class="p">[</span><span class="n">compression</span><span class="p">]</span><span class="si">}</span><span class="s2"> when the compression is set to </span><span class="si">{</span><span class="n">compression</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">=</span> <span class="n">compression</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h6 id="etlrules.backends.common.io.files.WriteParquetFileRule" class="doc doc-heading">
        <code>
WriteParquetFileRule            (<span title="etlrules.backends.common.io.files.BaseWriteFileRule">BaseWriteFileRule</span>)
        </code>



<a href="#etlrules.backends.common.io.files.WriteParquetFileRule" class="headerlink" title="Permanent link">&para;</a></h6>

    <div class="doc doc-contents ">

      <p>Writes an existing dataframe to a parquet file on disk.</p>
<p>The rule is a final rule, which means it produces no additional outputs, it takes any of the existing outputs and writes it to disk.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># writes a file data.parquet and persists the main output of the previous rule to it
rule = WriteParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;)
rule.apply(data)

# writes a file test_data.parquet and persists the dataframe named input_data into it
rule = WriteParquetFileRule(&quot;test_data.parquet&quot;, &quot;/home/myuser/&quot;, named_input=&quot;input_data&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>file_name</code></td>
        <td><code>str</code></td>
        <td><p>The name of the parquet file to write to disk. It will be written in the directory
specified by the file_dir parameter.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>file_dir</code></td>
        <td><code>str</code></td>
        <td><p>The file directory where the file_name should be written.
Defaults to . (ie the current directory).</p></td>
        <td><code>&#39;.&#39;</code></td>
      </tr>
      <tr>
        <td><code>compression</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Compress the parquet file using a supported compression algorithms. Optional.
The following compression algorithms are supported: "snappy", "gzip", "brotli", "lz4", "zstd".</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Select by name the dataframe to write from the input data.
Optional. When not specified, the main output of the previous rule will be written.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/io/files.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">WriteParquetFileRule</span><span class="p">(</span><span class="n">BaseWriteFileRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Writes an existing dataframe to a parquet file on disk.</span>

<span class="sd">    The rule is a final rule, which means it produces no additional outputs, it takes any of the existing outputs and writes it to disk.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # writes a file data.parquet and persists the main output of the previous rule to it</span>
<span class="sd">        rule = WriteParquetFileRule(&quot;data.parquet&quot;, &quot;/home/myuser/&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # writes a file test_data.parquet and persists the dataframe named input_data into it</span>
<span class="sd">        rule = WriteParquetFileRule(&quot;test_data.parquet&quot;, &quot;/home/myuser/&quot;, named_input=&quot;input_data&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        file_name: The name of the parquet file to write to disk. It will be written in the directory</span>
<span class="sd">            specified by the file_dir parameter.</span>
<span class="sd">        file_dir: The file directory where the file_name should be written.</span>
<span class="sd">            Defaults to . (ie the current directory).</span>
<span class="sd">        compression: Compress the parquet file using a supported compression algorithms. Optional.</span>
<span class="sd">            The following compression algorithms are supported: &quot;snappy&quot;, &quot;gzip&quot;, &quot;brotli&quot;, &quot;lz4&quot;, &quot;zstd&quot;.</span>

<span class="sd">        named_input (Optional[str]): Select by name the dataframe to write from the input data.</span>
<span class="sd">            Optional. When not specified, the main output of the previous rule will be written.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">COMPRESSIONS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;snappy&quot;</span><span class="p">,</span> <span class="s2">&quot;gzip&quot;</span><span class="p">,</span> <span class="s2">&quot;brotli&quot;</span><span class="p">,</span> <span class="s2">&quot;lz4&quot;</span><span class="p">,</span> <span class="s2">&quot;zstd&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file_dir</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">compression</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">file_dir</span><span class="o">=</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> 
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">compression</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">compression</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">COMPRESSIONS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unsupported compression &#39;</span><span class="si">{</span><span class="n">compression</span><span class="si">}</span><span class="s2">&#39;. It must be one of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">COMPRESSIONS</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">=</span> <span class="n">compression</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>







  </div>

    </div>

  </div>




  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.joins" class="doc doc-heading">
        <code>joins</code>



<a href="#etlrules.backends.common.joins" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.joins.InnerJoinRule" class="doc doc-heading">
        <code>
InnerJoinRule            (<span title="etlrules.backends.common.joins.BaseJoinRule">BaseJoinRule</span>)
        </code>



<a href="#etlrules.backends.common.joins.InnerJoinRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Performs a database-style inner join operation on two data frames.</p>
<p>A join involves two data frames left_df <join> right_df with the result performing a
database style join or a merge of the two, with the resulting columns coming from both
dataframes.
For example, if the left dataframe has two columns A, B and the right dataframe has two
column A, C, and assuming A is the key column the result will have three columns A, B, C.
The rows that have the same value in the key column A will be merged on the same row in the
result dataframe.</p>
<p>An inner join specifies that only those rows that have key values in both left and right
will be copied over and merged into the result data frame. Any rows without corresponding
values on the other side (be it left or right) will be dropped from the result.</p>

<p><strong>Examples:</strong></p>
    
      <p>left dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  |
| 1  | a  |
| 2  | b  |
</code></pre></div></td></tr></table></div>
<p>right dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | C  |
| 1  | c  |
| 3  | d  |
</code></pre></div></td></tr></table></div>
<p>result (key columns=["A"])::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  | C  |
| 1  | a  | c  |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>named_input_left</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the left side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input_right</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the right side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_left</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the left data frame)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_right</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the right data frame).
If not set or set to None, the key_columns_left is used on the right dataframe too.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>suffixes</code></td>
        <td><code>Iterable[Optional[str]]</code></td>
        <td><p>A list or tuple of two values which will be set as suffixes for the columns in the
result data frame for those columns that have the same name (and are not key columns).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if any columns (keys) are missing from any of the two input data frames.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/joins.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">InnerJoinRule</span><span class="p">(</span><span class="n">BaseJoinRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Performs a database-style inner join operation on two data frames.</span>

<span class="sd">    A join involves two data frames left_df &lt;join&gt; right_df with the result performing a</span>
<span class="sd">    database style join or a merge of the two, with the resulting columns coming from both</span>
<span class="sd">    dataframes.</span>
<span class="sd">    For example, if the left dataframe has two columns A, B and the right dataframe has two</span>
<span class="sd">    column A, C, and assuming A is the key column the result will have three columns A, B, C.</span>
<span class="sd">    The rows that have the same value in the key column A will be merged on the same row in the</span>
<span class="sd">    result dataframe.</span>

<span class="sd">    An inner join specifies that only those rows that have key values in both left and right</span>
<span class="sd">    will be copied over and merged into the result data frame. Any rows without corresponding</span>
<span class="sd">    values on the other side (be it left or right) will be dropped from the result.</span>

<span class="sd">    Example:</span>

<span class="sd">    left dataframe::</span>

<span class="sd">        | A  | B  |</span>
<span class="sd">        | 1  | a  |</span>
<span class="sd">        | 2  | b  |</span>

<span class="sd">    right dataframe::</span>

<span class="sd">        | A  | C  |</span>
<span class="sd">        | 1  | c  |</span>
<span class="sd">        | 3  | d  |</span>

<span class="sd">    result (key columns=[&quot;A&quot;])::</span>

<span class="sd">        | A  | B  | C  |</span>
<span class="sd">        | 1  | a  | c  |</span>

<span class="sd">    Args:</span>
<span class="sd">        named_input_left (Optional[str]): Which dataframe to use as the input on the left side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_input_right (Optional[str]): Which dataframe to use as the input on the right side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        key_columns_left (Iterable[str]): A list or tuple of column names to join on (columns in the left data frame)</span>
<span class="sd">        key_columns_right (Optional[Iterable[str]]): A list or tuple of column names to join on (columns in the right data frame).</span>
<span class="sd">            If not set or set to None, the key_columns_left is used on the right dataframe too.</span>
<span class="sd">        suffixes (Iterable[Optional[str]]): A list or tuple of two values which will be set as suffixes for the columns in the</span>
<span class="sd">            result data frame for those columns that have the same name (and are not key columns).</span>

<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if any columns (keys) are missing from any of the two input data frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">JOIN_TYPE</span> <span class="o">=</span> <span class="s2">&quot;inner&quot;</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.joins.LeftJoinRule" class="doc doc-heading">
        <code>
LeftJoinRule            (<span title="etlrules.backends.common.joins.BaseJoinRule">BaseJoinRule</span>)
        </code>



<a href="#etlrules.backends.common.joins.LeftJoinRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Performs a database-style left join operation on two data frames.</p>
<p>A join involves two data frames left_df <join> right_df with the result performing a
database style join or a merge of the two, with the resulting columns coming from both
dataframes.
For example, if the left dataframe has two columns A, B and the right dataframe has two
column A, C, and assuming A is the key column the result will have three columns A, B, C.
The rows that have the same value in the key column A will be merged on the same row in the
result dataframe.</p>
<p>A left join specifies that all the rows in the left dataframe will be present in the result,
irrespective of whether there's a corresponding row with the same values in the key columns in
the right dataframe. The right columns will be populated with NaNs/None when there is no
corresponding row on the right.</p>

<p><strong>Examples:</strong></p>
    
      <p>left dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  |
| 1  | a  |
| 2  | b  |
</code></pre></div></td></tr></table></div>
<p>right dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | C  |
| 1  | c  |
| 3  | d  |
</code></pre></div></td></tr></table></div>
<p>result (key columns=["A"])::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  | C  |
| 1  | a  | c  |
| 2  | b  | NA |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>named_input_left</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the left side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input_right</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the right side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_left</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the left data frame)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_right</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the right data frame).
If not set or set to None, the key_columns_left is used on the right dataframe too.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>suffixes</code></td>
        <td><code>Iterable[Optional[str]]</code></td>
        <td><p>A list or tuple of two values which will be set as suffixes for the columns in the
result data frame for those columns that have the same name (and are not key columns).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if any columns (keys) are missing from any of the two input data frames.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/joins.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">LeftJoinRule</span><span class="p">(</span><span class="n">BaseJoinRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Performs a database-style left join operation on two data frames.</span>

<span class="sd">    A join involves two data frames left_df &lt;join&gt; right_df with the result performing a</span>
<span class="sd">    database style join or a merge of the two, with the resulting columns coming from both</span>
<span class="sd">    dataframes.</span>
<span class="sd">    For example, if the left dataframe has two columns A, B and the right dataframe has two</span>
<span class="sd">    column A, C, and assuming A is the key column the result will have three columns A, B, C.</span>
<span class="sd">    The rows that have the same value in the key column A will be merged on the same row in the</span>
<span class="sd">    result dataframe.</span>

<span class="sd">    A left join specifies that all the rows in the left dataframe will be present in the result,</span>
<span class="sd">    irrespective of whether there&#39;s a corresponding row with the same values in the key columns in</span>
<span class="sd">    the right dataframe. The right columns will be populated with NaNs/None when there is no</span>
<span class="sd">    corresponding row on the right.</span>

<span class="sd">    Example:</span>

<span class="sd">    left dataframe::</span>

<span class="sd">        | A  | B  |</span>
<span class="sd">        | 1  | a  |</span>
<span class="sd">        | 2  | b  |</span>

<span class="sd">    right dataframe::</span>

<span class="sd">        | A  | C  |</span>
<span class="sd">        | 1  | c  |</span>
<span class="sd">        | 3  | d  |</span>

<span class="sd">    result (key columns=[&quot;A&quot;])::</span>

<span class="sd">        | A  | B  | C  |</span>
<span class="sd">        | 1  | a  | c  |</span>
<span class="sd">        | 2  | b  | NA |</span>

<span class="sd">    Args:</span>
<span class="sd">        named_input_left (Optional[str]): Which dataframe to use as the input on the left side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_input_right (Optional[str]): Which dataframe to use as the input on the right side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        key_columns_left (Iterable[str]): A list or tuple of column names to join on (columns in the left data frame)</span>
<span class="sd">        key_columns_right (Optional[Iterable[str]]): A list or tuple of column names to join on (columns in the right data frame).</span>
<span class="sd">            If not set or set to None, the key_columns_left is used on the right dataframe too.</span>
<span class="sd">        suffixes (Iterable[Optional[str]]): A list or tuple of two values which will be set as suffixes for the columns in the</span>
<span class="sd">            result data frame for those columns that have the same name (and are not key columns).</span>

<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if any columns (keys) are missing from any of the two input data frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">JOIN_TYPE</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.joins.OuterJoinRule" class="doc doc-heading">
        <code>
OuterJoinRule            (<span title="etlrules.backends.common.joins.BaseJoinRule">BaseJoinRule</span>)
        </code>



<a href="#etlrules.backends.common.joins.OuterJoinRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Performs a database-style left join operation on two data frames.</p>
<p>A join involves two data frames left_df <join> right_df with the result performing a
database style join or a merge of the two, with the resulting columns coming from both
dataframes.
For example, if the left dataframe has two columns A, B and the right dataframe has two
column A, C, and assuming A is the key column the result will have three columns A, B, C.
The rows that have the same value in the key column A will be merged on the same row in the
result dataframe.</p>
<p>An outer join specifies that all the rows in the both left and right dataframes will be present
in the result, irrespective of whether there's a corresponding row with the same values in the
key columns in the other dataframe. The missing side will have its columns populated with NA
when the rows are missing.</p>

<p><strong>Examples:</strong></p>
    
      <p>left dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  |
| 1  | a  |
| 2  | b  |
</code></pre></div></td></tr></table></div>
<p>right dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | C  |
| 1  | c  |
| 3  | d  |
</code></pre></div></td></tr></table></div>
<p>result (key columns=["A"])::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  | C  |
| 1  | a  | c  |
| 2  | b  | NA |
| 3  | NA | d  |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>named_input_left</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the left side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input_right</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the right side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_left</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the left data frame)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_right</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the right data frame).
If not set or set to None, the key_columns_left is used on the right dataframe too.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>suffixes</code></td>
        <td><code>Iterable[Optional[str]]</code></td>
        <td><p>A list or tuple of two values which will be set as suffixes for the columns in the
result data frame for those columns that have the same name (and are not key columns).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if any columns (keys) are missing from any of the two input data frames.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/joins.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">OuterJoinRule</span><span class="p">(</span><span class="n">BaseJoinRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Performs a database-style left join operation on two data frames.</span>

<span class="sd">    A join involves two data frames left_df &lt;join&gt; right_df with the result performing a</span>
<span class="sd">    database style join or a merge of the two, with the resulting columns coming from both</span>
<span class="sd">    dataframes.</span>
<span class="sd">    For example, if the left dataframe has two columns A, B and the right dataframe has two</span>
<span class="sd">    column A, C, and assuming A is the key column the result will have three columns A, B, C.</span>
<span class="sd">    The rows that have the same value in the key column A will be merged on the same row in the</span>
<span class="sd">    result dataframe.</span>

<span class="sd">    An outer join specifies that all the rows in the both left and right dataframes will be present</span>
<span class="sd">    in the result, irrespective of whether there&#39;s a corresponding row with the same values in the</span>
<span class="sd">    key columns in the other dataframe. The missing side will have its columns populated with NA</span>
<span class="sd">    when the rows are missing.</span>

<span class="sd">    Example:</span>

<span class="sd">    left dataframe::</span>

<span class="sd">        | A  | B  |</span>
<span class="sd">        | 1  | a  |</span>
<span class="sd">        | 2  | b  |</span>

<span class="sd">    right dataframe::</span>

<span class="sd">        | A  | C  |</span>
<span class="sd">        | 1  | c  |</span>
<span class="sd">        | 3  | d  |</span>

<span class="sd">    result (key columns=[&quot;A&quot;])::</span>

<span class="sd">        | A  | B  | C  |</span>
<span class="sd">        | 1  | a  | c  |</span>
<span class="sd">        | 2  | b  | NA |</span>
<span class="sd">        | 3  | NA | d  |</span>

<span class="sd">    Args:</span>
<span class="sd">        named_input_left (Optional[str]): Which dataframe to use as the input on the left side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_input_right (Optional[str]): Which dataframe to use as the input on the right side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        key_columns_left (Iterable[str]): A list or tuple of column names to join on (columns in the left data frame)</span>
<span class="sd">        key_columns_right (Optional[Iterable[str]]): A list or tuple of column names to join on (columns in the right data frame).</span>
<span class="sd">            If not set or set to None, the key_columns_left is used on the right dataframe too.</span>
<span class="sd">        suffixes (Iterable[Optional[str]]): A list or tuple of two values which will be set as suffixes for the columns in the</span>
<span class="sd">            result data frame for those columns that have the same name (and are not key columns).</span>

<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if any columns (keys) are missing from any of the two input data frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">JOIN_TYPE</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.joins.RightJoinRule" class="doc doc-heading">
        <code>
RightJoinRule            (<span title="etlrules.backends.common.joins.BaseJoinRule">BaseJoinRule</span>)
        </code>



<a href="#etlrules.backends.common.joins.RightJoinRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Performs a database-style left join operation on two data frames.</p>
<p>A join involves two data frames left_df <join> right_df with the result performing a
database style join or a merge of the two, with the resulting columns coming from both
dataframes.
For example, if the left dataframe has two columns A, B and the right dataframe has two
column A, C, and assuming A is the key column the result will have three columns A, B, C.
The rows that have the same value in the key column A will be merged on the same row in the
result dataframe.</p>
<p>A right join specifies that all the rows in the right dataframe will be present in the result,
irrespective of whether there's a corresponding row with the same values in the key columns in
the left dataframe. The left columns will be populated with NA when there is no
corresponding row on the left.</p>

<p><strong>Examples:</strong></p>
    
      <p>left dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  |
| 1  | a  |
| 2  | b  |
</code></pre></div></td></tr></table></div>
<p>right dataframe::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | C  |
| 1  | c  |
| 3  | d  |
</code></pre></div></td></tr></table></div>
<p>result (key columns=["A"])::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>| A  | B  | C  |
| 1  | a  | c  |
| 3  | NA | d  |
</code></pre></div></td></tr></table></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A right join is equivalent to a left join with the dataframes inverted, ie:
left_df <left_join> right_df
is equivalent to
right_df <right_join> left_df
although the order of the rows will be different.</p>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>named_input_left</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the left side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input_right</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input on the right side of the join.
When set to None, the input is taken from the main output of the previous rule.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_left</code></td>
        <td><code>Iterable[str]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the left data frame)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>key_columns_right</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>A list or tuple of column names to join on (columns in the right data frame).
If not set or set to None, the key_columns_left is used on the right dataframe too.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>suffixes</code></td>
        <td><code>Iterable[Optional[str]]</code></td>
        <td><p>A list or tuple of two values which will be set as suffixes for the columns in the
result data frame for those columns that have the same name (and are not key columns).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if any columns (keys) are missing from any of the two input data frames.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/joins.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">RightJoinRule</span><span class="p">(</span><span class="n">BaseJoinRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Performs a database-style left join operation on two data frames.</span>

<span class="sd">    A join involves two data frames left_df &lt;join&gt; right_df with the result performing a</span>
<span class="sd">    database style join or a merge of the two, with the resulting columns coming from both</span>
<span class="sd">    dataframes.</span>
<span class="sd">    For example, if the left dataframe has two columns A, B and the right dataframe has two</span>
<span class="sd">    column A, C, and assuming A is the key column the result will have three columns A, B, C.</span>
<span class="sd">    The rows that have the same value in the key column A will be merged on the same row in the</span>
<span class="sd">    result dataframe.</span>

<span class="sd">    A right join specifies that all the rows in the right dataframe will be present in the result,</span>
<span class="sd">    irrespective of whether there&#39;s a corresponding row with the same values in the key columns in</span>
<span class="sd">    the left dataframe. The left columns will be populated with NA when there is no</span>
<span class="sd">    corresponding row on the left.</span>

<span class="sd">    Example:</span>

<span class="sd">    left dataframe::</span>

<span class="sd">        | A  | B  |</span>
<span class="sd">        | 1  | a  |</span>
<span class="sd">        | 2  | b  |</span>

<span class="sd">    right dataframe::</span>

<span class="sd">        | A  | C  |</span>
<span class="sd">        | 1  | c  |</span>
<span class="sd">        | 3  | d  |</span>

<span class="sd">    result (key columns=[&quot;A&quot;])::</span>

<span class="sd">        | A  | B  | C  |</span>
<span class="sd">        | 1  | a  | c  |</span>
<span class="sd">        | 3  | NA | d  |</span>

<span class="sd">    Note:</span>
<span class="sd">        A right join is equivalent to a left join with the dataframes inverted, ie:</span>
<span class="sd">        left_df &lt;left_join&gt; right_df</span>
<span class="sd">        is equivalent to</span>
<span class="sd">        right_df &lt;right_join&gt; left_df</span>
<span class="sd">        although the order of the rows will be different.</span>

<span class="sd">    Args:</span>
<span class="sd">        named_input_left (Optional[str]): Which dataframe to use as the input on the left side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_input_right (Optional[str]): Which dataframe to use as the input on the right side of the join.</span>
<span class="sd">            When set to None, the input is taken from the main output of the previous rule.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        key_columns_left (Iterable[str]): A list or tuple of column names to join on (columns in the left data frame)</span>
<span class="sd">        key_columns_right (Optional[Iterable[str]]): A list or tuple of column names to join on (columns in the right data frame).</span>
<span class="sd">            If not set or set to None, the key_columns_left is used on the right dataframe too.</span>
<span class="sd">        suffixes (Iterable[Optional[str]]): A list or tuple of two values which will be set as suffixes for the columns in the</span>
<span class="sd">            result data frame for those columns that have the same name (and are not key columns).</span>

<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if any columns (keys) are missing from any of the two input data frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">JOIN_TYPE</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.newcolumns" class="doc doc-heading">
        <code>newcolumns</code>



<a href="#etlrules.backends.common.newcolumns" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.newcolumns.AddNewColumnRule" class="doc doc-heading">
        <code>
AddNewColumnRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.newcolumns.AddNewColumnRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Adds a new column and sets it to the value of an evaluated expression.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code>Given df:
| A   | B  |
| 1   | 2  |
| 2   | 3  |
| 3   | 4  |
</code></pre></div></td></tr></table></div>
<blockquote>
<p>AddNewColumnRule("Sum", "df['A'] + df['B']").apply(df)</p>
</blockquote>
<p>Result::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  | Sum |
| 1   | 2  | 3   |
| 2   | 3  | 5   |
| 3   | 4  | 7   |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>output_column</code></td>
        <td><code>str</code></td>
        <td><p>The name of the new column to be added.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_expression</code></td>
        <td><code>str</code></td>
        <td><p>An expression that gets evaluated and produces the value for the new column.
The syntax: df["EXISTING_COL"] can be used in the expression to refer to other columns in the dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_type</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional type to convert the result to. If not specified, the type is determined from the
output of the expression, which can sometimes differ based on the backend.
If the input dataframe is empty, this type ensures the column will be of the specified type, rather than
default to string type.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if a column with the same name already exists in the dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ExpressionSyntaxError</code></td>
        <td><p>raised if the column expression has a Python syntax error.</p></td>
      </tr>
      <tr>
        <td><code>UnsupportedTypeError</code></td>
        <td><p>raised if the column_type parameter is specified and not supported.</p></td>
      </tr>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>raised if an operation is not supported between the types involved. raised when the column type is specified
but the conversion to that type fails.</p></td>
      </tr>
      <tr>
        <td><code>NameError</code></td>
        <td><p>raised if an unknown variable is used</p></td>
      </tr>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>raised if you try to use an unknown column (i.e. df['ANY_UNKNOWN_COLUMN'])</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implementation will try to use dataframe operations for performance, but when those are not supported it
will fallback to row level operations.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NA are treated slightly differently between dataframe level operations and row level.
At dataframe level operations, NAs in operations will make the result be NA.
In row level operations, NAs will generally raise a TypeError.
To avoid such behavior, fill the NAs before performing operations.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/newcolumns.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">AddNewColumnRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Adds a new column and sets it to the value of an evaluated expression.</span>

<span class="sd">    Example::</span>

<span class="sd">        Given df:</span>
<span class="sd">        | A   | B  |</span>
<span class="sd">        | 1   | 2  |</span>
<span class="sd">        | 2   | 3  |</span>
<span class="sd">        | 3   | 4  |</span>

<span class="sd">    &gt; AddNewColumnRule(&quot;Sum&quot;, &quot;df[&#39;A&#39;] + df[&#39;B&#39;]&quot;).apply(df)</span>

<span class="sd">    Result::</span>

<span class="sd">        | A   | B  | Sum |</span>
<span class="sd">        | 1   | 2  | 3   |</span>
<span class="sd">        | 2   | 3  | 5   |</span>
<span class="sd">        | 3   | 4  | 7   |</span>

<span class="sd">    Args:</span>
<span class="sd">        output_column: The name of the new column to be added.</span>
<span class="sd">        column_expression: An expression that gets evaluated and produces the value for the new column.</span>
<span class="sd">            The syntax: df[&quot;EXISTING_COL&quot;] can be used in the expression to refer to other columns in the dataframe.</span>
<span class="sd">        column_type: An optional type to convert the result to. If not specified, the type is determined from the</span>
<span class="sd">            output of the expression, which can sometimes differ based on the backend.</span>
<span class="sd">            If the input dataframe is empty, this type ensures the column will be of the specified type, rather than</span>
<span class="sd">            default to string type.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if a column with the same name already exists in the dataframe.</span>
<span class="sd">        ExpressionSyntaxError: raised if the column expression has a Python syntax error.</span>
<span class="sd">        UnsupportedTypeError: raised if the column_type parameter is specified and not supported.</span>
<span class="sd">        TypeError: raised if an operation is not supported between the types involved. raised when the column type is specified</span>
<span class="sd">            but the conversion to that type fails.</span>
<span class="sd">        NameError: raised if an unknown variable is used</span>
<span class="sd">        KeyError: raised if you try to use an unknown column (i.e. df[&#39;ANY_UNKNOWN_COLUMN&#39;])</span>

<span class="sd">    Note:</span>
<span class="sd">        The implementation will try to use dataframe operations for performance, but when those are not supported it</span>
<span class="sd">        will fallback to row level operations.</span>

<span class="sd">    Note:</span>
<span class="sd">        NA are treated slightly differently between dataframe level operations and row level.</span>
<span class="sd">        At dataframe level operations, NAs in operations will make the result be NA.</span>
<span class="sd">        In row level operations, NAs will generally raise a TypeError.</span>
<span class="sd">        To avoid such behavior, fill the NAs before performing operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EXCLUDE_FROM_COMPARE</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_column_expression&#39;</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">column_expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">column_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="o">=</span> <span class="n">output_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_expression</span> <span class="o">=</span> <span class="n">column_expression</span>
        <span class="k">if</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">column_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_TYPES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported column type: &#39;</span><span class="si">{</span><span class="n">column_type</span><span class="si">}</span><span class="s2">&#39;. It must be one of: </span><span class="si">{</span><span class="n">SUPPORTED_TYPES</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_type</span> <span class="o">=</span> <span class="n">column_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_column_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column_expression</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_validate_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_columns</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="ow">in</span> <span class="n">df_columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ColumnAlreadyExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_column</span><span class="si">}</span><span class="s2"> already exists in the input dataframe.&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.newcolumns.AddRowNumbersRule" class="doc doc-heading">
        <code>
AddRowNumbersRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.newcolumns.AddRowNumbersRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Adds a new column with row numbers.</p>
<p>Example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code>Given df:
| A   | B  |
| 1   | 2  |
| 2   | 3  |
| 3   | 4  |
</code></pre></div></td></tr></table></div>
<blockquote>
<p>AddRowNumbersRule("Row_Number").apply(df)</p>
</blockquote>
<p>Result::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>| A   | B  | Row_Number |
| 1   | 2  | 0          |
| 2   | 3  | 1          |
| 3   | 4  | 2          |
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>output_column</code></td>
        <td><code>str</code></td>
        <td><p>The name of the new column to be added.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>start</code></td>
        <td><code>int</code></td>
        <td><p>The value to start the numbers from. Defaults to 0.</p></td>
        <td><code>0</code></td>
      </tr>
      <tr>
        <td><code>step</code></td>
        <td><code>int</code></td>
        <td><p>The increment to be used between row numbers. Defaults to 1.</p></td>
        <td><code>1</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if a column with the same name already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/newcolumns.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">AddRowNumbersRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Adds a new column with row numbers.</span>

<span class="sd">    Example::</span>

<span class="sd">        Given df:</span>
<span class="sd">        | A   | B  |</span>
<span class="sd">        | 1   | 2  |</span>
<span class="sd">        | 2   | 3  |</span>
<span class="sd">        | 3   | 4  |</span>

<span class="sd">    &gt; AddRowNumbersRule(&quot;Row_Number&quot;).apply(df)</span>

<span class="sd">    Result::</span>

<span class="sd">        | A   | B  | Row_Number |</span>
<span class="sd">        | 1   | 2  | 0          |</span>
<span class="sd">        | 2   | 3  | 1          |</span>
<span class="sd">        | 3   | 4  | 2          |</span>

<span class="sd">    Args:</span>
<span class="sd">        output_column: The name of the new column to be added.</span>
<span class="sd">        start: The value to start the numbers from. Defaults to 0.</span>
<span class="sd">        step: The increment to be used between row numbers. Defaults to 1.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if a column with the same name already exists in the dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="o">=</span> <span class="n">output_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>

    <span class="k">def</span> <span class="nf">_validate_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_columns</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_column</span> <span class="ow">in</span> <span class="n">df_columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ColumnAlreadyExistsError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_column</span><span class="si">}</span><span class="s2"> already exists in the input dataframe.&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.numeric" class="doc doc-heading">
        <code>numeric</code>



<a href="#etlrules.backends.common.numeric" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.numeric.AbsRule" class="doc doc-heading">
        <code>
AbsRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.numeric.AbsRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Converts numbers to absolute values.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = AbsRule(&quot;col_A&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The name of the column to convert to absolute values.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional new column with the absolute values.
If provided the existing column is unchanged and a new column is created with the absolute values.
If not provided, the result is updated in place.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/numeric.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">AbsRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Converts numbers to absolute values.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        rule = AbsRule(&quot;col_A&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The name of the column to convert to absolute values.</span>
<span class="sd">        output_column (Optional[str]): An optional new column with the absolute values.</span>
<span class="sd">            If provided the existing column is unchanged and a new column is created with the absolute values.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if a column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.numeric.RoundRule" class="doc doc-heading">
        <code>
RoundRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.numeric.RoundRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Rounds a set of columns to specified decimal places.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># rounds Col_A to 2dps
rule = RoundRule(&quot;Col_A&quot;, 2)
rule.apply(data)

# rounds Col_B to 0dps and output the results into Col_C, Col_B remains unchanged
rule = RoundRule(&quot;Col_B&quot;, 0, output_column=&quot;Col_C&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A column with values to round as per the specified scale.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>scale</code></td>
        <td><code>Union[int, Sequence[int]]</code></td>
        <td><p>An integer specifying the number of decimal places to round to.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional name for a new column with the rounded values.
If provided, the existing column is unchanged and the new column is created with the results.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/numeric.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">RoundRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Rounds a set of columns to specified decimal places.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # rounds Col_A to 2dps</span>
<span class="sd">        rule = RoundRule(&quot;Col_A&quot;, 2)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # rounds Col_B to 0dps and output the results into Col_C, Col_B remains unchanged</span>
<span class="sd">        rule = RoundRule(&quot;Col_B&quot;, 0, output_column=&quot;Col_C&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column: A column with values to round as per the specified scale.</span>
<span class="sd">        scale: An integer specifying the number of decimal places to round to.</span>
<span class="sd">        output_column (Optional[str]): An optional name for a new column with the rounded values.</span>
<span class="sd">            If provided, the existing column is unchanged and the new column is created with the results.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if a column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">output_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;scale must be an integer value&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.strings" class="doc doc-heading">
        <code>strings</code>



<a href="#etlrules.backends.common.strings" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrCapitalizeRule" class="doc doc-heading">
        <code>
StrCapitalizeRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrCapitalizeRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Converts the values in a string column to capitalized values.</p>
<p>Capitalization will convert the first letter in the string to upper case and the rest of the letters
to lower case.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = StrCapitalizeRule(&quot;col_A&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A string column with the values to capitalize.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional new names for the column with the capitalized values.
If provided, the existing column is unchanged, and a new column is created with the capitalized values.
If not provided, the result is updated in place.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrCapitalizeRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Converts the values in a string column to capitalized values.</span>

<span class="sd">    Capitalization will convert the first letter in the string to upper case and the rest of the letters</span>
<span class="sd">    to lower case.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        rule = StrCapitalizeRule(&quot;col_A&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A string column with the values to capitalize.</span>
<span class="sd">        output_column (Optional[str]): An optional new names for the column with the capitalized values.</span>
<span class="sd">            If provided, the existing column is unchanged, and a new column is created with the capitalized values.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if a column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrExtractRule" class="doc doc-heading">
        <code>
StrExtractRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>, <span title="etlrules.rule.ColumnsInOutMixin">ColumnsInOutMixin</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrExtractRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Extract substrings from strings columns using regular expressions.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code># extracts the number between start_ and _end
# ie: for an input value of start_1234_end - will extract 1234 in col_A
rule = StrExtractRule(&quot;col_A&quot;, regular_expression=r&quot;start_([\d]*)_end&quot;)
rule.apply(data)

# extracts with multiple groups, extracting the single digit at the end as well
# for an input value of start_1234_end_9, col_1 will extract 1234, col_2 will extract 9
rule = StrExtractRule(&quot;col_A&quot;, regular_expression=r&quot;start_([\d]*)_end_([\d])&quot;, output_columns=[&quot;col_1&quot;, &quot;col_2&quot;])
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A column to extract data from.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>regular_expression</code></td>
        <td><code>str</code></td>
        <td><p>The regular expression used to extract data.
The regular expression must have 1 or more groups - ie sections between brackets.
The groups do the actual extraction of data.
If there is a single group, then the column can be modified in place (ie no output_columns are needed) but
if there are multiple groups, then output_columns must be specified as each group will be extracted in a new
output column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>keep_original_value</code></td>
        <td><code>bool</code></td>
        <td><p>Only used in case there isn't a match and it specifies if NA should be used in the output or the original value.
Defaults: True.
If the regular expression has multiple groups and therefore multiple output_columns, only the first output column
will keep the original value, the rest will be populated with NA.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>output_columns</code></td>
        <td><code>Optional[Iterable[str]]</code></td>
        <td><p>A list of new names for the result columns.
Optional. If provided, it must have one output_column per regular expression group.
For example, given the regular expression "a_([\d])_([\d])" with 2 groups, then
the output columns must have 2 columns (one per group) - for example ["out_1", "out_2"].
The existing columns are unchanged, and new columns are created with extracted values.
If not provided, the result is updated in place (only possible if the regular expression has a single group).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if an output_column already exists in the dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raised if output_columns is provided and not the same length as the number of groups in the regular expression.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrExtractRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">,</span> <span class="n">ColumnsInOutMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Extract substrings from strings columns using regular expressions.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # extracts the number between start_ and _end</span>
<span class="sd">        # ie: for an input value of start_1234_end - will extract 1234 in col_A</span>
<span class="sd">        rule = StrExtractRule(&quot;col_A&quot;, regular_expression=r&quot;start_([\d]*)_end&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">        # extracts with multiple groups, extracting the single digit at the end as well</span>
<span class="sd">        # for an input value of start_1234_end_9, col_1 will extract 1234, col_2 will extract 9</span>
<span class="sd">        rule = StrExtractRule(&quot;col_A&quot;, regular_expression=r&quot;start_([\d]*)_end_([\d])&quot;, output_columns=[&quot;col_1&quot;, &quot;col_2&quot;])</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A column to extract data from.</span>
<span class="sd">        regular_expression: The regular expression used to extract data.</span>
<span class="sd">            The regular expression must have 1 or more groups - ie sections between brackets.</span>
<span class="sd">            The groups do the actual extraction of data.</span>
<span class="sd">            If there is a single group, then the column can be modified in place (ie no output_columns are needed) but</span>
<span class="sd">            if there are multiple groups, then output_columns must be specified as each group will be extracted in a new</span>
<span class="sd">            output column.</span>
<span class="sd">        keep_original_value: Only used in case there isn&#39;t a match and it specifies if NA should be used in the output or the original value.</span>
<span class="sd">            Defaults: True.</span>
<span class="sd">            If the regular expression has multiple groups and therefore multiple output_columns, only the first output column</span>
<span class="sd">            will keep the original value, the rest will be populated with NA.</span>
<span class="sd">        output_columns (Optional[Iterable[str]]): A list of new names for the result columns.</span>
<span class="sd">            Optional. If provided, it must have one output_column per regular expression group.</span>
<span class="sd">            For example, given the regular expression &quot;a_([\d])_([\d])&quot; with 2 groups, then</span>
<span class="sd">            the output columns must have 2 columns (one per group) - for example [&quot;out_1&quot;, &quot;out_2&quot;].</span>
<span class="sd">            The existing columns are unchanged, and new columns are created with extracted values.</span>
<span class="sd">            If not provided, the result is updated in place (only possible if the regular expression has a single group).</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if an output_column already exists in the dataframe.</span>
<span class="sd">        ValueError: raised if output_columns is provided and not the same length as the number of groups in the regular expression.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">regular_expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keep_original_value</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_columns</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_column</span> <span class="o">=</span> <span class="n">input_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_col</span> <span class="k">for</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="n">output_columns</span><span class="p">]</span> <span class="k">if</span> <span class="n">output_columns</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regular_expression</span> <span class="o">=</span> <span class="n">regular_expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regular_expression</span><span class="p">)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_expr</span><span class="o">.</span><span class="n">groups</span>
        <span class="k">assert</span> <span class="n">groups</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;The regular expression must have at least 1 group - ie a section in () - which gets extracted.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span><span class="p">)</span> <span class="o">!=</span> <span class="n">groups</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The regular expression has </span><span class="si">{</span><span class="n">groups</span><span class="si">}</span><span class="s2"> group(s), the output_columns must have </span><span class="si">{</span><span class="n">groups</span><span class="si">}</span><span class="s2"> column(s).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">groups</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The regular expression has more than 1 groups in which case output_columns must be specified (one per group).&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_original_value</span> <span class="o">=</span> <span class="n">keep_original_value</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrLowerRule" class="doc doc-heading">
        <code>
StrLowerRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrLowerRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Converts the values in a string column to lower case.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = StrLowerRule(&quot;col_A&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A string column to convert to lower case.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional new names for the column with the lower case values.
If provided, the existing column is unchanged, and a new column is created with the lower case values.
If not provided, the result is updated in place.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrLowerRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Converts the values in a string column to lower case.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        rule = StrLowerRule(&quot;col_A&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A string column to convert to lower case.</span>
<span class="sd">        output_column (Optional[str]): An optional new names for the column with the lower case values.</span>
<span class="sd">            If provided, the existing column is unchanged, and a new column is created with the lower case values.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if a column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrPadRule" class="doc doc-heading">
        <code>
StrPadRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrPadRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Makes strings of a given width (justifies) by padding left or right with a fill character.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code># a value of ABCD will ABCD....
rule = StrPadRule(&quot;col_A&quot;, width=8, fill_character=&quot;.&quot;, how=&quot;right&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A string column to be padded.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>width</code></td>
        <td><code>int</code></td>
        <td><p>Pad with the fill_character to this width.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fill_character</code></td>
        <td><code>str</code></td>
        <td><p>Character to fill with. Defaults to whitespace.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>how</code></td>
        <td><code>Literal[&#39;left&#39;, &#39;right&#39;]</code></td>
        <td><p>How should the stripping be done. One of left or right.
Left pads at the beggining of the string, right pads at the end. Default: left.</p></td>
        <td><code>&#39;left&#39;</code></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional new column with the padded results.
If provided, the existing column is unchanged and a new column is created with the results.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrPadRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Makes strings of a given width (justifies) by padding left or right with a fill character.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # a value of ABCD will ABCD....</span>
<span class="sd">        rule = StrPadRule(&quot;col_A&quot;, width=8, fill_character=&quot;.&quot;, how=&quot;right&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A string column to be padded.</span>
<span class="sd">        width: Pad with the fill_character to this width.</span>
<span class="sd">        fill_character: Character to fill with. Defaults to whitespace.</span>
<span class="sd">        how: How should the stripping be done. One of left or right.</span>
<span class="sd">            Left pads at the beggining of the string, right pads at the end. Default: left.</span>
<span class="sd">        output_column (Optional[str]): An optional new column with the padded results.</span>
<span class="sd">            If provided, the existing column is unchanged and a new column is created with the results.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if a column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">PAD_LEFT</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
    <span class="n">PAD_RIGHT</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fill_character</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">PAD_LEFT</span><span class="p">,</span> <span class="n">PAD_RIGHT</span><span class="p">]</span><span class="o">=</span><span class="n">PAD_LEFT</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PAD_LEFT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PAD_RIGHT</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unknown how parameter </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">. It must be one of: </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PAD_LEFT</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">PAD_RIGHT</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">how</span> <span class="o">=</span> <span class="n">how</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_character</span> <span class="o">=</span> <span class="n">fill_character</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrSplitRejoinRule" class="doc doc-heading">
        <code>
StrSplitRejoinRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrSplitRejoinRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Splits the values in a string column into an array of substrings based on a string separator then rejoin with a new separator, optionally sorting the substrings.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The output is an array of substrings which can optionally be limited via the limit parameter to only
include the first <limit> number of substrings.</p>
</div>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code># splits the col_A column on ,
# &quot;b,d;a,c&quot; will be split and rejoined as &quot;b|c|d;a&quot;
rule = StrSplitRejoinRule(&quot;col_A&quot;, separator=&quot;,&quot;, new_separator=&quot;|&quot;, sort=&quot;ascending&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>The column to split and rejoin.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>separator</code></td>
        <td><code>str</code></td>
        <td><p>A literal value to split the string by.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>limit</code></td>
        <td><code>Optional[int]</code></td>
        <td><p>A limit to the number of substrings. If specified, only the first <limit> substrings are returned
plus an additional remainder. At most, limit + 1 substrings are returned with the last beind the remainder.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>new_separator</code></td>
        <td><code>str</code></td>
        <td><p>A new separator used to rejoin the substrings.</p></td>
        <td><code>&#39;,&#39;</code></td>
      </tr>
      <tr>
        <td><code>sort</code></td>
        <td><code>Optional[Literal[&#39;ascending&#39;, &#39;descending&#39;]]</code></td>
        <td><p>Optionally sorts the substrings before rejoining using the new_separator.
It can be set to either ascending or descending, sorting the substrings accordingly.
When the value is set to None, there is no sorting.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional new column to hold the result.
If provided, the existing column is unchanged and a new column is created with the result.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrSplitRejoinRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Splits the values in a string column into an array of substrings based on a string separator then rejoin with a new separator, optionally sorting the substrings.</span>

<span class="sd">    Note:</span>
<span class="sd">        The output is an array of substrings which can optionally be limited via the limit parameter to only</span>
<span class="sd">        include the first &lt;limit&gt; number of substrings.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # splits the col_A column on ,</span>
<span class="sd">        # &quot;b,d;a,c&quot; will be split and rejoined as &quot;b|c|d;a&quot;</span>
<span class="sd">        rule = StrSplitRejoinRule(&quot;col_A&quot;, separator=&quot;,&quot;, new_separator=&quot;|&quot;, sort=&quot;ascending&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): The column to split and rejoin.</span>
<span class="sd">        separator: A literal value to split the string by.</span>
<span class="sd">        limit: A limit to the number of substrings. If specified, only the first &lt;limit&gt; substrings are returned</span>
<span class="sd">            plus an additional remainder. At most, limit + 1 substrings are returned with the last beind the remainder.</span>
<span class="sd">        new_separator: A new separator used to rejoin the substrings.</span>
<span class="sd">        sort: Optionally sorts the substrings before rejoining using the new_separator.</span>
<span class="sd">            It can be set to either ascending or descending, sorting the substrings accordingly.</span>
<span class="sd">            When the value is set to None, there is no sorting.</span>
<span class="sd">        output_column (Optional[str]): An optional new column to hold the result.</span>
<span class="sd">            If provided, the existing column is unchanged and a new column is created with the result.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SORT_ASCENDING</span> <span class="o">=</span> <span class="s2">&quot;ascending&quot;</span>
    <span class="n">SORT_DESCENDING</span> <span class="o">=</span> <span class="s2">&quot;descending&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_separator</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="n">SORT_ASCENDING</span><span class="p">,</span> <span class="n">SORT_DESCENDING</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">separator</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">=</span> <span class="n">separator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_separator</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_separator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_separator</span> <span class="o">=</span> <span class="n">new_separator</span>
        <span class="k">assert</span> <span class="n">sort</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SORT_ASCENDING</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SORT_DESCENDING</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span> <span class="o">=</span> <span class="n">sort</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrSplitRule" class="doc doc-heading">
        <code>
StrSplitRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrSplitRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Splits a string into an array of substrings based on a string separator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The output is an array of substrings which can optionally be limited via the limit parameter to only
include the first <limit> number of substrings.
If you need the output to be a string, perhaps joined on a different separator and optionally sorted
then use the StrSplitRejoinRule rule.</p>
</div>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code># splits the col_A column on ,
# &quot;a,b;c,d&quot; will be split as [&quot;a&quot;, &quot;b;c&quot;, &quot;d&quot;]
rule = StrSplitRule(&quot;col_A&quot;, separator=&quot;,&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A string column to split.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>separator</code></td>
        <td><code>str</code></td>
        <td><p>A literal value to split the string by.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>limit</code></td>
        <td><code>Optional[int]</code></td>
        <td><p>A limit to the number of substrings. If specified, only the first <limit> substrings are returned
plus an additional remainder. At most, limit + 1 substrings are returned with the last beind the remainder.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional column to hold the result of the split.
If provided, the existing column is unchanged and a new column is created with the result.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if the input_column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrSplitRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Splits a string into an array of substrings based on a string separator.</span>

<span class="sd">    Note:</span>
<span class="sd">        The output is an array of substrings which can optionally be limited via the limit parameter to only</span>
<span class="sd">        include the first &lt;limit&gt; number of substrings.</span>
<span class="sd">        If you need the output to be a string, perhaps joined on a different separator and optionally sorted</span>
<span class="sd">        then use the StrSplitRejoinRule rule.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # splits the col_A column on ,</span>
<span class="sd">        # &quot;a,b;c,d&quot; will be split as [&quot;a&quot;, &quot;b;c&quot;, &quot;d&quot;]</span>
<span class="sd">        rule = StrSplitRule(&quot;col_A&quot;, separator=&quot;,&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A string column to split.</span>
<span class="sd">        separator: A literal value to split the string by.</span>
<span class="sd">        limit: A limit to the number of substrings. If specified, only the first &lt;limit&gt; substrings are returned</span>
<span class="sd">            plus an additional remainder. At most, limit + 1 substrings are returned with the last beind the remainder.</span>
<span class="sd">        output_column (Optional[str]): An optional column to hold the result of the split.</span>
<span class="sd">            If provided, the existing column is unchanged and a new column is created with the result.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if the input_column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">separator</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">=</span> <span class="n">separator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrStripRule" class="doc doc-heading">
        <code>
StrStripRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrStripRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Strips leading, trailing or both whitespaces or other characters from the values in the input column.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = StrStripRule(&quot;col_A&quot;, how=&quot;both&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A input column to strip characters from its values.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>how</code></td>
        <td><code>Literal[&#39;left&#39;, &#39;right&#39;, &#39;both&#39;]</code></td>
        <td><p>How should the stripping be done. One of left, right, both.
Left strips leading characters, right trailing characters and both at both ends.</p></td>
        <td><code>&#39;both&#39;</code></td>
      </tr>
      <tr>
        <td><code>characters</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>If set, it contains a list of characters to be stripped.
When not specified or when set to None, whitespace is removed.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional new column to hold the results.
If provided, the existing column is unchanged and a new column is created with the results.
If not provided, the result is updated in place.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrStripRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Strips leading, trailing or both whitespaces or other characters from the values in the input column.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        rule = StrStripRule(&quot;col_A&quot;, how=&quot;both&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A input column to strip characters from its values.</span>
<span class="sd">        how: How should the stripping be done. One of left, right, both.</span>
<span class="sd">            Left strips leading characters, right trailing characters and both at both ends.</span>
<span class="sd">        characters: If set, it contains a list of characters to be stripped.</span>
<span class="sd">            When not specified or when set to None, whitespace is removed.</span>
<span class="sd">        output_column (Optional[str]): An optional new column to hold the results.</span>
<span class="sd">            If provided, the existing column is unchanged and a new column is created with the results.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if a column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">STRIP_LEFT</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
    <span class="n">STRIP_RIGHT</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
    <span class="n">STRIP_BOTH</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">STRIP_LEFT</span><span class="p">,</span> <span class="n">STRIP_RIGHT</span><span class="p">,</span> <span class="n">STRIP_BOTH</span><span class="p">]</span><span class="o">=</span><span class="n">STRIP_BOTH</span><span class="p">,</span> <span class="n">characters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_column</span><span class="o">=</span><span class="n">input_column</span><span class="p">,</span> <span class="n">output_column</span><span class="o">=</span><span class="n">output_column</span><span class="p">,</span> <span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> 
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STRIP_BOTH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">STRIP_LEFT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">STRIP_RIGHT</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unknown how parameter </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">. It must be one of: </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STRIP_BOTH</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">STRIP_LEFT</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">STRIP_RIGHT</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">how</span> <span class="o">=</span> <span class="n">how</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">characters</span> <span class="o">=</span> <span class="n">characters</span> <span class="ow">or</span> <span class="kc">None</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">















  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.strings.StrUpperRule" class="doc doc-heading">
        <code>
StrUpperRule            (<span title="etlrules.backends.common.base.BaseAssignColumnRule">BaseAssignColumnRule</span>)
        </code>



<a href="#etlrules.backends.common.strings.StrUpperRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Converts the values in a string columns to upper case.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>rule = StrUpperRule(&quot;col_A&quot;)
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>input_column</code></td>
        <td><code>str</code></td>
        <td><p>A string column to convert to upper case.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_column</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional new names for the column with the upper case values.
If provided, the existing column is unchanged, and a new column is created with the upper case values.
If not provided, the result is updated in place.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised if a column doesn't exist in the input dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ColumnAlreadyExistsError</code></td>
        <td><p>raised in strict mode only if the output_column already exists in the dataframe.</p></td>
      </tr>
  </tbody>
</table>      <div class="admonition note">
<p class="admonition-title">Note</p>
<p>In non-strict mode, the overwriting of existing columns is ignored.</p>
</div>

        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/strings.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StrUpperRule</span><span class="p">(</span><span class="n">BaseAssignColumnRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Converts the values in a string columns to upper case.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        rule = StrUpperRule(&quot;col_A&quot;)</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        input_column (str): A string column to convert to upper case.</span>
<span class="sd">        output_column (Optional[str]): An optional new names for the column with the upper case values.</span>
<span class="sd">            If provided, the existing column is unchanged, and a new column is created with the upper case values.</span>
<span class="sd">            If not provided, the result is updated in place.</span>

<span class="sd">        named_input (Optional[str]): Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output (Optional[str]): Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name (Optional[str]): Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description (Optional[str]): Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict (bool): When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised if a column doesn&#39;t exist in the input dataframe.</span>
<span class="sd">        ColumnAlreadyExistsError: raised in strict mode only if the output_column already exists in the dataframe.</span>

<span class="sd">    Note:</span>
<span class="sd">        In non-strict mode, the overwriting of existing columns is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>







  </div>

    </div>

  </div>




  <div class="doc doc-object doc-module">



<h4 id="etlrules.backends.common.types" class="doc doc-heading">
        <code>types</code>



<a href="#etlrules.backends.common.types" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h5 id="etlrules.backends.common.types.TypeConversionRule" class="doc doc-heading">
        <code>
TypeConversionRule            (<a title="etlrules.rule.UnaryOpBaseRule" href="#etlrules.rule.UnaryOpBaseRule">UnaryOpBaseRule</a>)
        </code>



<a href="#etlrules.backends.common.types.TypeConversionRule" class="headerlink" title="Permanent link">&para;</a></h5>

    <div class="doc doc-contents ">

      <p>Converts the type of a given set of columns to other types.</p>
<p>Basic usage::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code># converts column A to int64, B to string and C to datetime
rule = TypeConversionRule({&quot;A&quot;: &quot;int64&quot;, &quot;B&quot;: &quot;string&quot;, &quot;C&quot;: &quot;datetime&quot;})
rule.apply(data)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>mapper</code></td>
        <td><code>Mapping[str, str]</code></td>
        <td><p>A dict with columns names as keys and the new types as values.
The supported types are: int8, int16, int32, int64, uint8, uint16,
uint32, uint64, float32, float64, string, boolean, datetime and timedelta.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>named_input</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Which dataframe to use as the input. Optional.
When not set, the input is taken from the main output.
Set it to a string value, the name of an output dataframe of a previous rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>named_output</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the output of this rule a name so it can be used by another rule as a named input. Optional.
When not set, the result of this rule will be available as the main output.
When set to a name (string), the result will be available as that named output.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Give the rule a name. Optional.
Named rules are more descriptive as to what they're trying to do/the intent.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Describe in detail what the rules does, how it does it. Optional.
Together with the name, the description acts as the documentation of the rule.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>bool</code></td>
        <td><p>When set to True, the rule does a stricter valiation. Default: True</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>MissingColumnError</code></td>
        <td><p>raised when a column specified in the mapper doesn't exist in the input data frame.</p></td>
      </tr>
      <tr>
        <td><code>UnsupportedTypeError</code></td>
        <td><p>raised when an unknown type is speified in the values of the mapper.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raised in strict mode if a value cannot be converted to the desired type.
In non strict mode, the exception is not raised and the value is converted to NA.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/backends/common/types.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">TypeConversionRule</span><span class="p">(</span><span class="n">UnaryOpBaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Converts the type of a given set of columns to other types.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        # converts column A to int64, B to string and C to datetime</span>
<span class="sd">        rule = TypeConversionRule({&quot;A&quot;: &quot;int64&quot;, &quot;B&quot;: &quot;string&quot;, &quot;C&quot;: &quot;datetime&quot;})</span>
<span class="sd">        rule.apply(data)</span>

<span class="sd">    Args:</span>
<span class="sd">        mapper: A dict with columns names as keys and the new types as values.</span>
<span class="sd">            The supported types are: int8, int16, int32, int64, uint8, uint16,</span>
<span class="sd">            uint32, uint64, float32, float64, string, boolean, datetime and timedelta.</span>

<span class="sd">        named_input: Which dataframe to use as the input. Optional.</span>
<span class="sd">            When not set, the input is taken from the main output.</span>
<span class="sd">            Set it to a string value, the name of an output dataframe of a previous rule.</span>
<span class="sd">        named_output: Give the output of this rule a name so it can be used by another rule as a named input. Optional.</span>
<span class="sd">            When not set, the result of this rule will be available as the main output.</span>
<span class="sd">            When set to a name (string), the result will be available as that named output.</span>
<span class="sd">        name: Give the rule a name. Optional.</span>
<span class="sd">            Named rules are more descriptive as to what they&#39;re trying to do/the intent.</span>
<span class="sd">        description: Describe in detail what the rules does, how it does it. Optional.</span>
<span class="sd">            Together with the name, the description acts as the documentation of the rule.</span>
<span class="sd">        strict: When set to True, the rule does a stricter valiation. Default: True</span>

<span class="sd">    Raises:</span>
<span class="sd">        MissingColumnError: raised when a column specified in the mapper doesn&#39;t exist in the input data frame.</span>
<span class="sd">        UnsupportedTypeError: raised when an unknown type is speified in the values of the mapper.</span>
<span class="sd">        ValueError: raised in strict mode if a value cannot be converted to the desired type.</span>
<span class="sd">            In non strict mode, the exception is not raised and the value is converted to NA.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;mapper needs to be a dict {column_name:type}&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="s2">&quot;mapper needs to be a dict {column_name:type} where the names are str&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_input</span><span class="o">=</span><span class="n">named_input</span><span class="p">,</span> <span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="n">mapper</span>
        <span class="k">for</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">type_str</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">type_str</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_TYPES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnsupportedTypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type &#39;</span><span class="si">{</span><span class="n">type_str</span><span class="si">}</span><span class="s2">&#39; for column &#39;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2">&#39; is not currently supported.&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">do_type_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Have you imported the rules from etlrules.backends.&lt;your_backend&gt; and not common?&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_df</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">columns_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">columns_set</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingColumnError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2">&#39; is missing in the data frame. Available columns: </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">columns_set</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assign_do_apply_dict</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">{</span>
            <span class="n">column_name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_type_conversion</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">type_str</span><span class="p">)</span> 
                <span class="k">for</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">type_str</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_df</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">














  </div>

    </div>

  </div>







  </div>

    </div>

  </div>




  </div>

    </div>

  </div>







  </div>

    </div>

  </div>




  <div class="doc doc-object doc-module">



<h2 id="etlrules.engine" class="doc doc-heading">
        <code>engine</code>



<a href="#etlrules.engine" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h3 id="etlrules.engine.RuleEngine" class="doc doc-heading">
        <code>
RuleEngine        </code>



<a href="#etlrules.engine.RuleEngine" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Run a set of extract/transform/load rules over a dataframe.</p>
<p>Takes in a plan with the definition of the extract/transform/load rules and it
runs it over a RuleData instance. The RuleData instance can be optionally pre-populated with
a input dataframe (in pipeline mode) or a sequence of named inputs (named dataframes).</p>
<p>The plan can have rules to extract data (ie add more dataframes to the RuleData). It can have
transform rules which will transform the existing dataframes (either in-place or produce new
named dataframes). It can also have rules to load data into external systems, e.g. files,
databases, API connections, etc.</p>
<p>At the end of a plan run, the RuleData instance passed in will contain the results of the run
(ie new dataframes/transformed dataframes) which can be inspected/operated on outside of the
rule engine.</p>

        <details class="quote">
          <summary>Source code in <code>etlrules/engine.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">RuleEngine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Run a set of extract/transform/load rules over a dataframe.</span>

<span class="sd">    Takes in a plan with the definition of the extract/transform/load rules and it</span>
<span class="sd">    runs it over a RuleData instance. The RuleData instance can be optionally pre-populated with</span>
<span class="sd">    a input dataframe (in pipeline mode) or a sequence of named inputs (named dataframes).</span>

<span class="sd">    The plan can have rules to extract data (ie add more dataframes to the RuleData). It can have</span>
<span class="sd">    transform rules which will transform the existing dataframes (either in-place or produce new</span>
<span class="sd">    named dataframes). It can also have rules to load data into external systems, e.g. files,</span>
<span class="sd">    databases, API connections, etc.</span>

<span class="sd">    At the end of a plan run, the RuleData instance passed in will contain the results of the run</span>
<span class="sd">    (ie new dataframes/transformed dataframes) which can be inspected/operated on outside of the</span>
<span class="sd">    rule engine.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="n">Plan</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plan</span><span class="p">,</span> <span class="n">Plan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plan</span> <span class="o">=</span> <span class="n">plan</span>

    <span class="k">def</span> <span class="nf">_get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]:</span>
        <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="o">.</span><span class="n">get_context</span><span class="p">())</span>
        <span class="n">context</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">get_context</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">context</span>

    <span class="k">def</span> <span class="nf">run_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleData</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_context</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="p">:</span>
                <span class="n">rule</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_get_topological_sorter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">graphlib</span><span class="o">.</span><span class="n">TopologicalSorter</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">graphlib</span><span class="o">.</span><span class="n">TopologicalSorter</span><span class="p">()</span>
        <span class="n">existing_named_outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">get_named_outputs</span><span class="p">())</span>
        <span class="n">named_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">has_output</span><span class="p">():</span>
                <span class="n">named_outputs_lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">get_all_named_outputs</span><span class="p">())</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">named_outputs_lst</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rule </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">/(name=</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">, index=</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">) has no named outputs.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">named_output</span> <span class="ow">in</span> <span class="n">named_outputs_lst</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">named_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rule </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">/(name=</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">, index=</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">) has empty named output.&quot;</span><span class="p">)</span>
                    <span class="n">existing_rule</span> <span class="o">=</span> <span class="n">named_outputs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">named_output</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">existing_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  
                        <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Named output &#39;</span><span class="si">{</span><span class="n">named_output</span><span class="si">}</span><span class="s2">&#39; is produced by multiple rules: </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">/(name=</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">) and </span><span class="si">{</span><span class="n">existing_rule</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">/(name=</span><span class="si">{</span><span class="n">existing_rule</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="n">named_outputs</span><span class="p">[</span><span class="n">named_output</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>
        <span class="n">named_output_clashes</span> <span class="o">=</span> <span class="n">existing_named_outputs</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">named_outputs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">named_output_clashes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GraphRuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Named output clashes. The following named outputs are produced by rules in the plan but they also exist in the input data, leading to ambiguity: </span><span class="si">{</span><span class="n">named_output_clashes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">has_input</span><span class="p">():</span>
                <span class="n">named_inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">get_all_named_inputs</span><span class="p">())</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">named_inputs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rule </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">/(name=</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">, index=</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">) has no named inputs.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">named_input</span> <span class="ow">in</span> <span class="n">named_inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">named_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rule </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">/(name=</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">, index=</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">) has empty named input.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">named_input</span> <span class="ow">in</span> <span class="n">named_outputs</span><span class="p">:</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">named_outputs</span><span class="p">[</span><span class="n">named_input</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">named_input</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_named_outputs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">GraphRuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rule </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">/(name=</span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">, index=</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">) requires a named_input=</span><span class="si">{</span><span class="n">named_input</span><span class="si">}</span><span class="s2"> which doesn&#39;t exist in the input data and it&#39;s not produced as a named output by any of the rules in the graph.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">run_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleData</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_topological_sorter</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_context</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">g</span><span class="o">.</span><span class="n">is_active</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">rule_idx</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">get_ready</span><span class="p">():</span>
                    <span class="n">rule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="n">rule_idx</span><span class="p">)</span>
                    <span class="n">rule</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">done</span><span class="p">(</span><span class="n">rule_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">validate_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">validate_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_topological_sorter</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">InvalidPlanError</span><span class="p">,</span> <span class="n">GraphRuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">RuleData</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;An empty plan cannot be run.&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">PlanMode</span><span class="o">.</span><span class="n">PIPELINE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_pipeline</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">PlanMode</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_graph</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Plan&#39;s mode cannot be determined.&quot;</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleData</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">RuleData</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="s2">&quot;An empty plan cannot be run.&quot;</span><span class="p">)</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">PlanMode</span><span class="o">.</span><span class="n">PIPELINE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_pipeline</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">PlanMode</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_graph</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="s2">&quot;Plan&#39;s mode cannot be determined.&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">


















  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="etlrules.exceptions" class="doc doc-heading">
        <code>exceptions</code>



<a href="#etlrules.exceptions" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.ColumnAlreadyExistsError" class="doc doc-heading">
        <code>
ColumnAlreadyExistsError            (<span title="Exception">Exception</span>)
        </code>



<a href="#etlrules.exceptions.ColumnAlreadyExistsError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>An attempt to create a column that already exists in the dataframe. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ColumnAlreadyExistsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; An attempt to create a column that already exists in the dataframe. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.ExpressionSyntaxError" class="doc doc-heading">
        <code>
ExpressionSyntaxError            (<span title="SyntaxError">SyntaxError</span>)
        </code>



<a href="#etlrules.exceptions.ExpressionSyntaxError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>A Python expression used to create a column, aggregate or other operations has a syntax error. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ExpressionSyntaxError</span><span class="p">(</span><span class="ne">SyntaxError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; A Python expression used to create a column, aggregate or other operations has a syntax error. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.GraphRuntimeError" class="doc doc-heading">
        <code>
GraphRuntimeError            (<span title="RuntimeError">RuntimeError</span>)
        </code>



<a href="#etlrules.exceptions.GraphRuntimeError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>There was an error when running a graph-mode plan. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">GraphRuntimeError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; There was an error when running a graph-mode plan. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.InvalidPlanError" class="doc doc-heading">
        <code>
InvalidPlanError            (<span title="Exception">Exception</span>)
        </code>



<a href="#etlrules.exceptions.InvalidPlanError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>The plan failed validation. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">InvalidPlanError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; The plan failed validation. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.MissingColumnError" class="doc doc-heading">
        <code>
MissingColumnError            (<span title="Exception">Exception</span>)
        </code>



<a href="#etlrules.exceptions.MissingColumnError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>An operation is being applied to a column that is not present in the input data frame. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">MissingColumnError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; An operation is being applied to a column that is not present in the input data frame. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.SQLError" class="doc doc-heading">
        <code>
SQLError            (<span title="RuntimeError">RuntimeError</span>)
        </code>



<a href="#etlrules.exceptions.SQLError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>There was an error during the execution of a sql statement. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">SQLError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; There was an error during the execution of a sql statement. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.SchemaError" class="doc doc-heading">
        <code>
SchemaError            (<span title="Exception">Exception</span>)
        </code>



<a href="#etlrules.exceptions.SchemaError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>An operation needs a certain schema for the dataframe which is not present. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">SchemaError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; An operation needs a certain schema for the dataframe which is not present. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>



  <div class="doc doc-object doc-class">



<h3 id="etlrules.exceptions.UnsupportedTypeError" class="doc doc-heading">
        <code>
UnsupportedTypeError            (<span title="Exception">Exception</span>)
        </code>



<a href="#etlrules.exceptions.UnsupportedTypeError" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>A type conversion is attempted to a type that is not supported. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/exceptions.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">UnsupportedTypeError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; A type conversion is attempted to a type that is not supported. &quot;&quot;&quot;</span>
</code></pre></div>
        </details>


    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="etlrules.plan" class="doc doc-heading">
        <code>plan</code>



<a href="#etlrules.plan" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h3 id="etlrules.plan.Plan" class="doc doc-heading">
        <code>
Plan        </code>



<a href="#etlrules.plan.Plan" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>A plan to manipulate one or multiple dataframes with a set of rules.</p>
<p>A plan is a blueprint on how to extract one or more dataframes from various sources (e.g. files or
other data sources), how to transform those dataframes by adding calculated columns, joining
different dataframe, aggregating, sorting, etc. and ultimately how to load that into a data store
(files or other data stores).</p>
<p>A plan can operate in two modes: pipeline or graph. A pipeline graph is a simple type of plan where
each rule take its input from the previous rule's output. A graph plan is more complex as it allows
rules to produce named outputs which can then be used by other rules. This ultimately builds a dag
(directed acyclic graph) of rule dependencies. A graph allows branching and joining back allowing
complex logic. Rules are executed in the order of dependency and not in the order they are added to
the plan. By comparison, pipelines implement a single input/single output mode where rules are
executed in the order they are added to the plan.</p>
<p>Pipeline example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>plan = Plan()
plan.add_rule(SortRule([&#39;A&#39;]))
plan.add_rule(ProjectRule([&#39;A&#39;, &#39;B&#39;]))
plan.add_rule(RenameRule({&#39;A&#39;: &#39;AA&#39;, &#39;B&#39;: &#39;BB&#39;}))
</code></pre></div></td></tr></table></div>
<p>Graph example::</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>plan = Plan()
plan.add_rule(SortRule([&#39;A&#39;], named_input=&quot;input&quot;, named_output=&quot;sorted_data&quot;))
plan.add_rule(ProjectRule([&#39;A&#39;, &#39;B&#39;], named_input=&quot;sorted_data&quot;, named_output=&quot;projected_data&quot;))
plan.add_rule(RenameRule({&#39;A&#39;: &#39;AA&#39;, &#39;B&#39;: &#39;BB&#39;}, named_input=&quot;projected_data&quot;, named_output=&quot;renamed_data&quot;))
</code></pre></div></td></tr></table></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rules that are used in graph mode should take a named_input and produce a named_output. Rules
that use the pipeline mode must not used named inputs/outputs. The two type of rules cannot be
used in the same plan as that leads to ambiguity.</p>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>mode</code></td>
        <td><code>Optional[Literal[&#39;pipeline&#39;, &#39;graph&#39;]]</code></td>
        <td><p>One of pipeline or graph, the type of the graph. Optional.
In pipeline mode, rules don't use named inputs/outputs and they are run in the same order they are
added to the plan, with each rule taking the input from the previous rule.
In graph mode, rules use named inputs/outputs which create a directed acyclical graph of
dependency. The rules are run in the order of dependency.</p>
<p>When not specified, it is inferred from the first rule in the plan.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>A name for the plan. Optional.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>description</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>An optional documentation for the plan.
This can include what the plan does, its purpose and detailed information about how it works.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>context</code></td>
        <td><code>Optional[Mapping[str, Union[str, int, float, bool]]]</code></td>
        <td><p>An optional key-value mapping which can be used in rules via string substitutions.
It can be used as arguments into the plan to tweak the running of the plan by providing different
values for certain arguments with each run.
The types of the values can be: strings, int, float, boolean (True or False).</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>strict</code></td>
        <td><code>Optional[bool]</code></td>
        <td><p>A hint about how the plan should be executed.
When None, then the plan has no hint to provide and its the caller deciding whether to run it
in a strict mode or not.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>InvalidPlanError</code></td>
        <td><p>if pipeline mode rules are mixed with graph mode rules</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Plan</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; A plan to manipulate one or multiple dataframes with a set of rules.</span>

<span class="sd">    A plan is a blueprint on how to extract one or more dataframes from various sources (e.g. files or</span>
<span class="sd">    other data sources), how to transform those dataframes by adding calculated columns, joining</span>
<span class="sd">    different dataframe, aggregating, sorting, etc. and ultimately how to load that into a data store</span>
<span class="sd">    (files or other data stores).</span>

<span class="sd">    A plan can operate in two modes: pipeline or graph. A pipeline graph is a simple type of plan where</span>
<span class="sd">    each rule take its input from the previous rule&#39;s output. A graph plan is more complex as it allows</span>
<span class="sd">    rules to produce named outputs which can then be used by other rules. This ultimately builds a dag</span>
<span class="sd">    (directed acyclic graph) of rule dependencies. A graph allows branching and joining back allowing</span>
<span class="sd">    complex logic. Rules are executed in the order of dependency and not in the order they are added to</span>
<span class="sd">    the plan. By comparison, pipelines implement a single input/single output mode where rules are</span>
<span class="sd">    executed in the order they are added to the plan.</span>

<span class="sd">    Pipeline example::</span>

<span class="sd">        plan = Plan()</span>
<span class="sd">        plan.add_rule(SortRule([&#39;A&#39;]))</span>
<span class="sd">        plan.add_rule(ProjectRule([&#39;A&#39;, &#39;B&#39;]))</span>
<span class="sd">        plan.add_rule(RenameRule({&#39;A&#39;: &#39;AA&#39;, &#39;B&#39;: &#39;BB&#39;}))</span>

<span class="sd">    Graph example::</span>

<span class="sd">        plan = Plan()</span>
<span class="sd">        plan.add_rule(SortRule([&#39;A&#39;], named_input=&quot;input&quot;, named_output=&quot;sorted_data&quot;))</span>
<span class="sd">        plan.add_rule(ProjectRule([&#39;A&#39;, &#39;B&#39;], named_input=&quot;sorted_data&quot;, named_output=&quot;projected_data&quot;))</span>
<span class="sd">        plan.add_rule(RenameRule({&#39;A&#39;: &#39;AA&#39;, &#39;B&#39;: &#39;BB&#39;}, named_input=&quot;projected_data&quot;, named_output=&quot;renamed_data&quot;))</span>

<span class="sd">    Note:</span>
<span class="sd">        Rules that are used in graph mode should take a named_input and produce a named_output. Rules</span>
<span class="sd">        that use the pipeline mode must not used named inputs/outputs. The two type of rules cannot be</span>
<span class="sd">        used in the same plan as that leads to ambiguity.</span>

<span class="sd">    Args:</span>
<span class="sd">        mode: One of pipeline or graph, the type of the graph. Optional.</span>
<span class="sd">            In pipeline mode, rules don&#39;t use named inputs/outputs and they are run in the same order they are</span>
<span class="sd">            added to the plan, with each rule taking the input from the previous rule.</span>
<span class="sd">            In graph mode, rules use named inputs/outputs which create a directed acyclical graph of</span>
<span class="sd">            dependency. The rules are run in the order of dependency.</span>

<span class="sd">            When not specified, it is inferred from the first rule in the plan.</span>
<span class="sd">        name: A name for the plan. Optional.</span>
<span class="sd">        description: An optional documentation for the plan.</span>
<span class="sd">            This can include what the plan does, its purpose and detailed information about how it works.</span>
<span class="sd">        context: An optional key-value mapping which can be used in rules via string substitutions.</span>
<span class="sd">            It can be used as arguments into the plan to tweak the running of the plan by providing different</span>
<span class="sd">            values for certain arguments with each run.</span>
<span class="sd">            The types of the values can be: strings, int, float, boolean (True or False).</span>
<span class="sd">        strict: A hint about how the plan should be executed.</span>
<span class="sd">            When None, then the plan has no hint to provide and its the caller deciding whether to run it</span>
<span class="sd">            in a strict mode or not.</span>

<span class="sd">    Raises:</span>
<span class="sd">        InvalidPlanError: if pipeline mode rules are mixed with graph mode rules</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;pipeline&#39;</span><span class="p">,</span> <span class="s1">&#39;graph&#39;</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">strict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strict</span> <span class="o">=</span> <span class="n">strict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_check_plan_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">:</span> <span class="n">BaseRule</span><span class="p">):</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_new_rule_mode</span> <span class="o">=</span> <span class="n">plan_mode_from_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_new_rule_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">_new_rule_mode</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidPlanError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mixing of rules taking named inputs and rules with no named inputs is not supported. (</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> vs. </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">&#39;s mode </span><span class="si">{</span><span class="n">_new_rule_mode</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;pipeline&#39;</span><span class="p">,</span> <span class="s1">&#39;graph&#39;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the mode (pipeline or graph) of the plan. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">plan_mode_from_rules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span>

    <span class="k">def</span> <span class="nf">get_context</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span>

    <span class="k">def</span> <span class="nf">add_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">:</span> <span class="n">BaseRule</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Add a new rule to the plan.</span>

<span class="sd">        Args:</span>
<span class="sd">            rule: A rule instance to add to the plan</span>

<span class="sd">        Raises:</span>
<span class="sd">            InvalidPlanError: if the rules are mixed (pipeline vs. graph - ie. mixing use of named inputs/outputs and not using them)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">BaseRule</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_plan_mode</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span>

    <span class="k">def</span> <span class="nf">get_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseRule</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the rule at a certain index as per order of addition to the plan. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return True if the plan has no rules, False otherwise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A boolean to indicate if the plan is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Serialize the plan to a dict.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary with the plan representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">rule</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
            <span class="s2">&quot;strict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">,</span>
            <span class="s2">&quot;rules&quot;</span><span class="p">:</span> <span class="n">rules</span>
        <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dct</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Plan&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Deserialize a plan from a dict.</span>

<span class="sd">        Args:</span>
<span class="sd">            dct: A dictionary to create the plan from</span>
<span class="sd">            backend: One of the supported backends (ie pandas)</span>
<span class="sd">        Returns:</span>
<span class="sd">            A new instance of a Plan.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">Plan</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span>
            <span class="n">description</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;description&quot;</span><span class="p">),</span>
            <span class="n">context</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;context&quot;</span><span class="p">),</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;strict&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">rules</span> <span class="o">=</span> <span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rules&quot;</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">BaseRule</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">backend</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="nf">to_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Serialize the plan to yaml. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">yml</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Plan&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Deserialize a plan from yaml.</span>

<span class="sd">        Args:</span>
<span class="sd">            yml: The yaml string to create the plan from</span>
<span class="sd">            backend: A supported backend (ie pandas)</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new instance of a Plan.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">yml</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Plan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">description</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strict</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">strict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">rules</span>
        <span class="p">)</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">












  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.add_rule" class="doc doc-heading">
<code class="highlight language-python"><span class="n">add_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span></code>


<a href="#etlrules.plan.Plan.add_rule" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Add a new rule to the plan.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>rule</code></td>
        <td><code>BaseRule</code></td>
        <td><p>A rule instance to add to the plan</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>InvalidPlanError</code></td>
        <td><p>if the rules are mixed (pipeline vs. graph - ie. mixing use of named inputs/outputs and not using them)</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">:</span> <span class="n">BaseRule</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Add a new rule to the plan.</span>

<span class="sd">    Args:</span>
<span class="sd">        rule: A rule instance to add to the plan</span>

<span class="sd">    Raises:</span>
<span class="sd">        InvalidPlanError: if the rules are mixed (pipeline vs. graph - ie. mixing use of named inputs/outputs and not using them)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">BaseRule</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_check_plan_mode</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.from_dict" class="doc doc-heading">
<code class="highlight language-python"><span class="n">from_dict</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-classmethod"><code>classmethod</code></small>
  </span>

<a href="#etlrules.plan.Plan.from_dict" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Deserialize a plan from a dict.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dct</code></td>
        <td><code>dict</code></td>
        <td><p>A dictionary to create the plan from</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>backend</code></td>
        <td><code>str</code></td>
        <td><p>One of the supported backends (ie pandas)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Plan</code></td>
      <td><p>A new instance of a Plan.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dct</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Plan&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Deserialize a plan from a dict.</span>

<span class="sd">    Args:</span>
<span class="sd">        dct: A dictionary to create the plan from</span>
<span class="sd">        backend: One of the supported backends (ie pandas)</span>
<span class="sd">    Returns:</span>
<span class="sd">        A new instance of a Plan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="n">Plan</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span>
        <span class="n">description</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;description&quot;</span><span class="p">),</span>
        <span class="n">context</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;context&quot;</span><span class="p">),</span>
        <span class="n">strict</span><span class="o">=</span><span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;strict&quot;</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">rules</span> <span class="o">=</span> <span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rules&quot;</span><span class="p">,</span> <span class="p">())</span>
    <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">BaseRule</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">backend</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">instance</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.from_yaml" class="doc doc-heading">
<code class="highlight language-python"><span class="n">from_yaml</span><span class="p">(</span><span class="n">yml</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-classmethod"><code>classmethod</code></small>
  </span>

<a href="#etlrules.plan.Plan.from_yaml" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Deserialize a plan from yaml.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>yml</code></td>
        <td><code>str</code></td>
        <td><p>The yaml string to create the plan from</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>backend</code></td>
        <td><code>str</code></td>
        <td><p>A supported backend (ie pandas)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Plan</code></td>
      <td><p>A new instance of a Plan.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">yml</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Plan&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Deserialize a plan from yaml.</span>

<span class="sd">    Args:</span>
<span class="sd">        yml: The yaml string to create the plan from</span>
<span class="sd">        backend: A supported backend (ie pandas)</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new instance of a Plan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dct</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">yml</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.get_mode" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#etlrules.plan.Plan.get_mode" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Return the mode (pipeline or graph) of the plan. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;pipeline&#39;</span><span class="p">,</span> <span class="s1">&#39;graph&#39;</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the mode (pipeline or graph) of the plan. &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">plan_mode_from_rules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.get_rule" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span></code>


<a href="#etlrules.plan.Plan.get_rule" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Return the rule at a certain index as per order of addition to the plan. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseRule</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the rule at a certain index as per order of addition to the plan. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.is_empty" class="doc doc-heading">
<code class="highlight language-python"><span class="n">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#etlrules.plan.Plan.is_empty" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Return True if the plan has no rules, False otherwise.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>bool</code></td>
      <td><p>A boolean to indicate if the plan is empty.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return True if the plan has no rules, False otherwise.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A boolean to indicate if the plan is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.to_dict" class="doc doc-heading">
<code class="highlight language-python"><span class="n">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#etlrules.plan.Plan.to_dict" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Serialize the plan to a dict.</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dict</code></td>
      <td><p>A dictionary with the plan representation.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Serialize the plan to a dict.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary with the plan representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">rule</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
        <span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
        <span class="s2">&quot;strict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict</span><span class="p">,</span>
        <span class="s2">&quot;rules&quot;</span><span class="p">:</span> <span class="n">rules</span>
    <span class="p">}</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h4 id="etlrules.plan.Plan.to_yaml" class="doc doc-heading">
<code class="highlight language-python"><span class="n">to_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#etlrules.plan.Plan.to_yaml" class="headerlink" title="Permanent link">&para;</a></h4>

    <div class="doc doc-contents ">

      <p>Serialize the plan to yaml. </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/plan.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Serialize the plan to yaml. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>










  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="etlrules.rule" class="doc doc-heading">
        <code>rule</code>



<a href="#etlrules.rule" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h3 id="etlrules.rule.BinaryOpBaseRule" class="doc doc-heading">
        <code>
BinaryOpBaseRule            (<span title="etlrules.rule.BaseRule">BaseRule</span>)
        </code>



<a href="#etlrules.rule.BinaryOpBaseRule" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Base class for binary operation rules (ie operations taking two data frames as input). </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/rule.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BinaryOpBaseRule</span><span class="p">(</span><span class="n">BaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Base class for binary operation rules (ie operations taking two data frames as input). &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_input_left</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">named_input_right</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">named_input_left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">named_input_left</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">named_input_left</span>
        <span class="k">assert</span> <span class="n">named_input_right</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">named_input_right</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">named_input_right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_input_left</span> <span class="o">=</span> <span class="n">named_input_left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_input_right</span> <span class="o">=</span> <span class="n">named_input_right</span>

    <span class="k">def</span> <span class="nf">_get_input_df_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_input_left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get_main_output</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get_named_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_input_left</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_input_df_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_input_right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get_main_output</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get_named_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_input_right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_all_named_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_input_left</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_input_right</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>




  <div class="doc doc-object doc-class">



<h3 id="etlrules.rule.UnaryOpBaseRule" class="doc doc-heading">
        <code>
UnaryOpBaseRule            (<span title="etlrules.rule.BaseRule">BaseRule</span>)
        </code>



<a href="#etlrules.rule.UnaryOpBaseRule" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Base class for unary operation rules (ie operations taking a single data frame as input). </p>

        <details class="quote">
          <summary>Source code in <code>etlrules/rule.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">UnaryOpBaseRule</span><span class="p">(</span><span class="n">BaseRule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Base class for unary operation rules (ie operations taking a single data frame as input). &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">named_output</span><span class="o">=</span><span class="n">named_output</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">named_input</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">named_input</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">named_input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_input</span> <span class="o">=</span> <span class="n">named_input</span>

    <span class="k">def</span> <span class="nf">_get_input_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">RuleData</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get_main_output</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get_named_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_input</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_all_named_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_input</span>
</code></pre></div>
        </details>



  <div class="doc doc-children">













  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="etlrules.runner" class="doc doc-heading">
        <code>runner</code>



<a href="#etlrules.runner" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">










  <div class="doc doc-object doc-function">



<h3 id="etlrules.runner.load_plan" class="doc doc-heading">
<code class="highlight language-python"><span class="n">load_plan</span><span class="p">(</span><span class="n">plan_file</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span></code>


<a href="#etlrules.runner.load_plan" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Load a plan from a yaml file.</p>
<p>Basic usage:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>from etlrules import load_plan
plan = load_plan(&quot;/home/someuser/some_plan.yml&quot;, &quot;pandas&quot;)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>plan_file</code></td>
        <td><code>str</code></td>
        <td><p>A path to a yaml file with the plan definition</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>backend</code></td>
        <td><code>str</code></td>
        <td><p>One of the supported backends (e.g. pandas, polars, etc.)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Plan</code></td>
      <td><p>A Plan instance deserialized from the yaml file.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/runner.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">load_plan</span><span class="p">(</span><span class="n">plan_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Plan</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Load a plan from a yaml file.</span>

<span class="sd">    Basic usage:</span>

<span class="sd">        from etlrules import load_plan</span>
<span class="sd">        plan = load_plan(&quot;/home/someuser/some_plan.yml&quot;, &quot;pandas&quot;)</span>

<span class="sd">    Args:</span>
<span class="sd">        plan_file: A path to a yaml file with the plan definition</span>
<span class="sd">        backend: One of the supported backends (e.g. pandas, polars, etc.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        A Plan instance deserialized from the yaml file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">plan_file</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">plan_f</span><span class="p">:</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="n">plan_f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Plan</span><span class="o">.</span><span class="n">from_yaml</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h3 id="etlrules.runner.run_plan" class="doc doc-heading">
<code class="highlight language-python"><span class="n">run_plan</span><span class="p">(</span><span class="n">plan_file</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span></code>


<a href="#etlrules.runner.run_plan" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Runs a plan from a yaml file with a given backend.</p>
<p>Basic usage:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code>from etlrules import run_plan
data = run_plan(&quot;/home/someuser/some_plan.yml&quot;, &quot;pandas&quot;)
</code></pre></div></td></tr></table></div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>plan_file</code></td>
        <td><code>str</code></td>
        <td><p>A path to a yaml file with the plan definition</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>backend</code></td>
        <td><code>str</code></td>
        <td><p>One of the supported backends (e.g. pandas, polars, etc.)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>RuleData</code></td>
      <td><p>A RuleData instance which contains the result dataframe(s).</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>etlrules/runner.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">run_plan</span><span class="p">(</span><span class="n">plan_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RuleData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Runs a plan from a yaml file with a given backend.</span>

<span class="sd">    Basic usage:</span>

<span class="sd">        from etlrules import run_plan</span>
<span class="sd">        data = run_plan(&quot;/home/someuser/some_plan.yml&quot;, &quot;pandas&quot;)</span>

<span class="sd">    Args:</span>
<span class="sd">        plan_file: A path to a yaml file with the plan definition</span>
<span class="sd">        backend: One of the supported backends (e.g. pandas, polars, etc.)</span>

<span class="sd">    Returns:</span>
<span class="sd">        A RuleData instance which contains the result dataframe(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plan</span> <span class="o">=</span> <span class="n">load_plan</span><span class="p">(</span><span class="n">plan_file</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">get_args_parser</span><span class="p">(</span><span class="n">plan</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">RuleData</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
    <span class="n">engine</span> <span class="o">=</span> <span class="n">RuleEngine</span><span class="p">(</span><span class="n">plan</span><span class="p">)</span>
    <span class="n">engine</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>




  </div>

    </div>

  </div>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../usage/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Usage" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Usage
            </div>
          </div>
        </a>
      
      
        
        <a href="../contributing/" class="md-footer__link md-footer__link--next" aria-label="Next: Contributing" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Contributing
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    <a href="http://www.jieyu.ai" target="_blank" rel="noopener" title="Tweet" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
    </a>
  
    
    
    <a href="http://www.jieyu.ai" target="_blank" rel="noopener" title="Facebook" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg>
    </a>
  
    
    
    <a href="https://github.com/ciprianmiclaus/etlrules" target="_blank" rel="noopener" title="Github" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    <a href="mailto:ciprianm@gmail.com" target="_blank" rel="noopener" title="" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m20 8-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.indexes", "navigation.tabs", "navigation.instant", "navigation.tabs.sticky"], "search": "../assets/javascripts/workers/search.092fa1f6.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../assets/javascripts/bundle.5a9542cf.min.js"></script>
      
    
  </body>
</html>